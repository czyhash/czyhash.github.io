<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Node.js 学习笔记 | CHEN`Blog</title><meta name="keywords" content="Nodejs"><meta name="author" content="CHEN,2017721025@qq.com"><meta name="copyright" content="CHEN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Node.js 学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Node.js 学习笔记">
<meta property="og:url" content="http://example.com/posts/20e30b1b.html">
<meta property="og:site_name" content="CHEN&#96;Blog">
<meta property="og:description" content="Node.js 学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sway.office.com/s/P3GYAOioiuDWbvRM/images/TUmp-j1PvPYlOe?quality=225">
<meta property="article:published_time" content="2020-03-02T16:00:00.000Z">
<meta property="article:modified_time" content="2022-09-27T01:05:08.762Z">
<meta property="article:author" content="CHEN">
<meta property="article:tag" content="Nodejs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sway.office.com/s/P3GYAOioiuDWbvRM/images/TUmp-j1PvPYlOe?quality=225"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/posts/20e30b1b"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="#49b1f5"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Node.js 学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-09-27 09:05:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/_custom/fixed_comment.css"  media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/_custom/twikoo_beautify.css"  media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="CHEN`Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://sway.office.com/s/9RTcWmiwBO2AUl3z/images/QWXHCV0DS2RHjH?quality=400" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-video"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://sway.office.com/s/P3GYAOioiuDWbvRM/images/TUmp-j1PvPYlOe?quality=225')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CHEN`Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-video"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Node.js 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-03-02T16:00:00.000Z" title="发表于 2020-03-03 00:00:00">2020-03-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-27T01:05:08.762Z" title="更新于 2022-09-27 09:05:08">2022-09-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/nodejs/">nodejs</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Node.js 学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><pre><code>console.log(&#39;Hello world&#39;);
</code></pre><p>console.log与c语言中的printf功能类似,也接受任意多个参数,支持%d,%s变量引用:</p>
<pre><code>console.log(&#39;%s:%d&#39;,&#39;Hello&#39;,25);
Hello:25
</code></pre><p>运行无参数的 node 将会启动一个 JavaScript 的交互式 shell</p>
<pre><code>$ node
&gt; console.log(&#39;Hello World&#39;);
Hello World
undefined
</code></pre><p>在任何时候，连续按两次 Ctrl + C 即可退出Node.js 的 REPL 模式。</p>
<hr>
<h2 id="建立HTTP服务器"><a href="#建立HTTP服务器" class="headerlink" title="建立HTTP服务器"></a>建立HTTP服务器</h2><p>首先创建一个名为app.js的文件:</p>
<pre><code>//app.js
var http = require(&#39;http&#39;);
http.createServer(function(req, res) &#123;
  res.writeHead(200, &#123;&#39;Content-Type&#39;: &#39;text/html&#39;&#125;);
  res.write(&#39;&lt;h1&gt;Node.js&lt;/h1&gt;&#39;);
  res.end(&#39;&lt;p&gt;Hello World&lt;/p&gt;&#39;);
&#125;).listen(3000);
console.log(&quot;HTTP server is listening at port 3000.&quot;);
</code></pre><p>接下来运行 node app.js命令，打开浏览器访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:3000">http://127.0.0.1:3000</a></p>
<blockquote>
<p><h1>Node.js</h1><br>  <h3>Hello World</h3></p>
</blockquote>
<p>这个程序调用了 Node.js 提供的 http 模块，对所有 HTTP 请求答复同样的内容并监听 3000 端口.</p>
<p><strong>Node.js</strong> <strong>教程</strong></p>
<p><strong>Node.js</strong></p>
<p>Node.js 是能够在伺服器端运行 JavaScript 的开放原始码、跨平台 JavaScript 执行环境。</p>
<p>Node.js 由 Node.js 基金会持有和维护 ，并与 Linux 基金会有合作关系 。</p>
<p>Node.js 采用 Google 开发的 V8 执行程式码，使用事件驱动、非阻塞和非同步输入输出模型等技术来提高效能，可优化应用程式的传输量和规模。</p>
<p>这些技术通常用于资料密集的即时应用程式。</p>
<p>一句话概括就是：JS 非常牛 X！</p>
<p>我个人的理解比较简单：PHP 是 WEB 开发的过去式，Node.js 是 WEB 开发的将来时！</p>
<p><strong>一切能用 JS 来做的事情，最终都会用 JS 来做！</strong></p>
<p>尽力推动 JS 生态，包括并不限网页开发，Chrome 扩展开发，PC 桌面应用的开发，手机端应用的开发，服务器任务批处理脚本等等；</p>
<p><strong>Node.js</strong> <strong>对前端生态的推动有里程碑的意义</strong></p>
<p>Node.js 大部分基本模组都用 JavaScript 语言编写。</p>
<p>在 Node.js 出现之前，JavaScript 通常作为用户端程式设计语言使用，以 JavaScript 写出的程式常在用户的浏览器上执行。</p>
<p>Node.js 的出现使 JavaScript 也能用于伺服器端编程。</p>
<p>Node.js 含有一系列内置模组，使得程式可以脱离 Apache HTTP Server 或 IIS，作为独立伺服器执行。</p>
<p><strong>使用的版本</strong></p>
<p>我们可以使用以下命令来查看当前的 Node 版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. node -v</span><br><span class="line"></span><br><span class="line">2. npm -v</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>不同版本间可能是有差异的。</p>
<p><strong>Hello World**</strong>！**</p>
<p><strong>脚本模式</strong></p>
<p>以下是我们的第一个 Node.js 程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. console.log(&quot;Hello World&quot;);</span><br></pre></td></tr></table></figure>
<p>保存该文件，文件名为 helloworld.js， 并通过 node 命令来执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. node helloworld.js</span><br></pre></td></tr></table></figure>
<p>程序执行后，正常的话，就会在终端输出 Hello World。</p>
<p><strong>交互模式</strong></p>
<p>打开终端，键入 node 进入命令交互模式，可以输入一条代码语句后立即执行并显示结果，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ node&gt; console.log(&#x27;Hello World!&#x27;);Hello World!</span><br></pre></td></tr></table></figure>
<p><strong>执行绪</strong></p>
<p>Node.js 以单执行绪执行，使用非阻塞 I/O 呼叫，这样既可以支援数以万计的并行连线，又不会因多执行绪本身的特点而带来麻烦。</p>
<p>众多请求只使用单执行绪的设计意味著可以用于建立高并行应用程式。Node.js 应用程式的设计目标是任何需要操作 I/O 的函式都使用回呼函式。</p>
<p>这种设计的缺点是，如果不使用 cluster、StrongLoop Process Manager 或 pm2 等模组，Node.js 就难以处理多核或多执行绪等情况。</p>
<p><strong>V8</strong></p>
<p>主条目：V8 (JavaScript 引擎）</p>
<p>V8 是为 Google Chrome 设计的 JavaScript 运行引擎，Google 于 2008 年将其开源。V8 用 C++ 写成，它将 JavaScript 源代码编译成本地机器码而不是解释执行。</p>
<p>Node.js 用 libuv 来处理异步事件，而 V8 提供了 JavaScript 的实时运行环境。</p>
<p>libuv 是一个网络和文件系统功能的抽象层，既可以用于 Windows 又可以用于符合 POSIX 标准的系统，例如 Linux、OS X 和 Unix。</p>
<p>Node.js 的核心功能被包含进一个 JavaScript 库，并通过 C++ 将各部分与操作系统进行联系。</p>
<p><strong>npm</strong></p>
<p>主条目：node 包管理器</p>
<p>npm 是 Node.js 附带的包管理器。</p>
<p>npm 是一个命令行工具，用于从 NPM Registry 中下载、安装 Node.js 程序，同时解决依赖问题。</p>
<p>npm 提高了开发的速度，因为它能够负责第三方 Node.js 程序的安装与管理。</p>
<p><strong>统一 API</strong></p>
<p>Node.js 将浏览器、数据（例如 MongoDB 或 CouchDB）等组合到一起，通过 JSON 提供一个统一的接口。</p>
<p>由于前端框架和一些基本的后端开发技术（如 MVC、MVP、MVVM 等）变得流行，</p>
<p>Node.js 也支持客户端和服务器端重新利用相同的模型和接口。</p>
<p><strong>事件循环</strong></p>
<p>Node.js 将其注册到操作系统中，这样可以及时注意到新连接的产生。当新连接产生时，操作系统会产生一个回调。</p>
<p>在 Node.js 运行时内部，每个连接都被分配一个小型的堆。</p>
<p>与其他服务器程序不同的是，Node.js 不使用进程或线程处理连接，而是采用事件循环来处理并发连接。</p>
<p>而且 Node.js 的事件循环不需要手动调用。</p>
<p>在回调函数定义之后，服务器进入事件循环。</p>
<p>当回调函数均被执行完毕之后，Node.js 结束事件循环。</p>
<p><strong>开发工具</strong></p>
<p><strong>桌面</strong> <strong>IDE</strong></p>
<ul>
<li>Atom（免费、开源软件）</li>
<li>Brackets（免费、开源软件）</li>
<li>Sublime Text（商业软件）</li>
<li>JetBrains IntelliJ IDEA（商业软件）</li>
<li><strong>JetBrains WebStorm**</strong>（商业软件，五星推荐）**</li>
<li>Microsoft Visual Studio with     Node.js Tools for Visual Studio（商业软件）</li>
<li>Microsoft Visual Studio with     TypeScript（商业软件）</li>
<li>Nodeclipse Enide Studio（免费、开源软件、在 Eclipse 基础上开发）</li>
<li>NoFlo –与 GNOME API 集成的流式开发环境</li>
<li>Visual Studio Code（免费、开源软件）</li>
</ul>
<p><strong>在线编辑器</strong></p>
<ul>
<li>Koding</li>
<li>Codenvy IDE</li>
<li>Cloud9 IDE</li>
<li>Codiad</li>
</ul>
<p><strong>运行时和调试器</strong></p>
<ul>
<li><strong>Visual Studio     Code</strong> <strong>（五星推荐）</strong></li>
<li>Microsoft Visual Studio（商业）with Node.js Tools for     Visual Studio（免费）</li>
<li>Microsoft WebMatrix（免费、闭源软件）</li>
</ul>
<p><strong>框架</strong></p>
<ul>
<li>服务器端框架：Express.js, Socket.IO,     Koa.js, Hapi.js, Total.js</li>
<li>MVC 框架：Meteor, Derby, Sails, Mean, MeanJS,     Tower.js, Nombo, Geddy, Compound, Yahoo! Mojito</li>
</ul>
<p><strong>下载</strong></p>
<p><strong>Node.js</strong> <strong>下载地址</strong></p>
<p><a target="_blank" rel="noopener" href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p>
<p><strong>Node.js</strong> <strong>历史版本</strong></p>
<p>Node.js 历史版本下载地址：<a target="_blank" rel="noopener" href="https://nodejs.org/dist/">https://nodejs.org/dist/</a></p>
<p><strong>这里是 Nodejs 历史版本大全</strong></p>
<p><strong>Windows Node.js</strong> <strong>安装</strong></p>
<p><strong>Node.js</strong> <strong>安装配置</strong></p>
<p>本章节我们将向大家介绍在 Windows 上安装 Node.js 的方法。</p>
<p>Node.js 安装包及源码下载地址为：<a target="_blank" rel="noopener" href="https://nodejs.org/en/download/。">https://nodejs.org/en/download/。</a></p>
<p><img src="C:\Users\86133\Pictures\node.jpg" alt="nodejs_download"></p>
<p>你可以根据不同平台系统选择你需要的 Node.js 安装包。</p>
<p><strong>Windows</strong> <strong>上安装 Node.js</strong></p>
<p>你可以采用以下两种方式来安装。</p>
<p><strong>1**</strong>、<strong>**Windows</strong> <strong>安装包</strong> <strong>(.msi)</strong></p>
<p>本文实例以 v10.xx.xx 版本为例，其他版本类似， 安装步骤：</p>
<p><strong>步骤</strong> <strong>1 :</strong> <strong>双击下载后的安装包</strong> <strong>v10.xx.xx**</strong>，如下所示：**</p>
<p><img src="C:\Users\86133\Pictures\node1.jpg" alt="install-node-msi-version-on-windows-step1"></p>
<p><strong>步骤</strong> <strong>2 :</strong> <strong>点击以上的</strong> <strong>Run**</strong>（运行），将出现如下界面：**</p>
<p><img src="C:\Users\86133\Pictures\node.jpd" alt="install-node-msi-version-on-windows-step2"></p>
<p><strong>步骤</strong> <strong>3 :</strong> <strong>勾选接受协议选项，点击</strong> <strong>next**</strong>（下一步）<strong> </strong>按钮<strong> </strong>:**</p>
<p><img src="C:\Users\86133\Pictures\node3.jpg" alt="install-node-msi-version-on-windows-step3"></p>
<p><strong>步骤</strong> <strong>4 :</strong> <strong>选择</strong> <strong>Node.js</strong> <strong>安装目录</strong></p>
<p>默认安装目录为 “C:\Program Files\nodejs\” , 你可以修改目录，并点击 next（下一步）：</p>
<p><strong>非常不推荐用户修改安装目录！！！使用默认的就好</strong></p>
<p><img src="C:\Users\86133\Pictures\node4.jpg" alt="install-node-msi-version-on-windows-step4"></p>
<p><strong>步骤</strong> <strong>5 :</strong> <strong>点击树形图标来选择你需要的安装模式</strong> <strong>,</strong> <strong>然后点击下一步</strong> <strong>next**</strong>（下一步）**</p>
<p><img src="C:\Users\86133\Pictures\node5.jpg" alt="install-node-msi-version-on-windows-step5"></p>
<p><strong>步骤</strong> <strong>6 :</strong> <strong>点击</strong> <strong>Install**</strong>（安装）<strong> </strong>开始安装<strong> </strong>Node.js<strong>**。你也可以点击</strong> <strong>Back**</strong>（返回）来修改先前的配置。<strong> </strong>然后并点击<strong> </strong>next<strong>**（下一步）：</strong></p>
<p><img src="C:\Users\86133\Pictures\node6.jpg" alt="install-node-msi-version-on-windows-step6"></p>
<p>安装过程：</p>
<p><img src="C:\Users\86133\Pictures\node7.jpg" alt="install-node-msi-version-on-windows-step7"></p>
<p>点击 Finish（完成）按钮退出安装向导。</p>
<p><img src="C:\Users\86133\Pictures\node8.jpg" alt="install-node-msi-version-on-windows-step8"></p>
<p>检测 PATH 环境变量是否配置了 Node.js，点击开始 =》运行 =》输入”cmd” =&gt; 输入命令”path”，输出如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">1. PATH=C:\WINDOWS\system32;</span><br><span class="line"></span><br><span class="line">2. C:\WINDOWS;</span><br><span class="line"></span><br><span class="line">3. C:\WINDOWS\System32\Wbem;</span><br><span class="line"></span><br><span class="line">4. C:\WINDOWS\System32\WindowsPowerShell\v1.0\;</span><br><span class="line"></span><br><span class="line">5. C:\Program Files (x86)\ATI Technologies\ATI.ACE\Core-Static;</span><br><span class="line"></span><br><span class="line">6. C:\WINDOWS\System32\OpenSSH\;</span><br><span class="line"></span><br><span class="line">7. E:\git\Git\cmd;</span><br><span class="line"></span><br><span class="line">8. E:\postgreSQL\install\pg11\bin;</span><br><span class="line"></span><br><span class="line">9. C:\Program Files\nodejs\;</span><br><span class="line"></span><br><span class="line">10. C:\Users\Administrator\.windows-build-tools\python27\;</span><br><span class="line"></span><br><span class="line">11. C:\Program Files\nodejs\node_modules\npm\node_modules\npm-lifecycle\node-gyp-bin;</span><br><span class="line"></span><br><span class="line">12. C:\Users\Administrator\AppData\Roaming\npm\node_modules\windows-build-tools\node_modules\.bin;</span><br><span class="line"></span><br><span class="line">13. C:\Users\Administrator\AppData\Roaming\npm\node_modules\.bin;</span><br><span class="line"></span><br><span class="line">14. C:\WINDOWS\system32;</span><br><span class="line"></span><br><span class="line">15. C:\WINDOWS;</span><br><span class="line"></span><br><span class="line">16. C:\WINDOWS\System32\Wbem;</span><br><span class="line"></span><br><span class="line">17. C:\WINDOWS\System32\WindowsPowerShell\v1.0\;</span><br><span class="line"></span><br><span class="line">18. C:\Program Files (x86)\ATI Technologies\ATI.ACE\Core-Static;</span><br><span class="line"></span><br><span class="line">19. C:\WINDOWS\System32\OpenSSH\;</span><br><span class="line"></span><br><span class="line">20. C:\Program Files\nodejs\;</span><br><span class="line"></span><br><span class="line">21. E:\git\Git\cmd;</span><br><span class="line"></span><br><span class="line">22. E:\postgreSQL\install\pg11\bin;</span><br><span class="line"></span><br><span class="line">23. C:\Users\Administrator\AppData\Local\Microsoft\WindowsApps;</span><br><span class="line"></span><br><span class="line">24. E:\vscode\install\Microsoft VS Code\bin;</span><br><span class="line"></span><br><span class="line">25. C:\Users\Administrator\AppData\Roaming\npm;</span><br><span class="line"></span><br><span class="line">26. C:\Users\Administrator\AppData\Local\BypassRuntm;</span><br><span class="line"></span><br><span class="line">27. C:\Users\Administrator\AppData\Local\GitHubDesktop\bin</span><br><span class="line"></span><br><span class="line">我们可以看到环境变量中已经包含了 C:\Program Files\nodejs\;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>检查 Node.js 版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. node -v</span><br><span class="line"></span><br><span class="line">2. npm -v</span><br></pre></td></tr></table></figure>
<p><strong>2**</strong>、<strong>**Windows</strong> <strong>二进制文件</strong> <strong>(.exe)</strong></p>
<p>使用 .exe 的安装包进行安装</p>
<p><strong>安装步骤</strong></p>
<p>步骤 1 : 双击下载的安装包 Node.exe ，将出现如下界面 :</p>
<p><img src="C:\Users\86133\Pictures\node9.jpg" alt="install-node-exe-on-windows-step1"></p>
<p>点击 Run（运行）按钮将出现命令行窗口：</p>
<p><img src="C:\Users\86133\Pictures\node10.jpg" alt="install-node-exe-on-windows-step21"></p>
<p><strong>测试 Node.js 是否安装成功</strong></p>
<p>进入 node.exe 所在的目录，</p>
<p>输出结果，说明你已经成功安装了 Node.js。</p>
<p><strong>Node.js</strong> <strong>创建第一个应用</strong></p>
<p>使用 Node.js 时做一个 WEB 服务的时候，我们不仅仅 在实现一个应用，同时还实现了整个 HTTP 服务器。</p>
<p>事实上，我们的 <strong>Web</strong> <strong>应用</strong> 以及对应的 <strong>Web</strong> <strong>服务器</strong> 基本上是一样的。</p>
<p>在我们创建 Node.js 第一个 “Hello, World!” 应用前，让我们先了解下 Node.js 应用是由哪几部分组成的：</p>
<ol>
<li>引入 required 模块：</li>
</ol>
<p>我们可以使用require</p>
<p>指令来载入 Node.js 模块。</p>
<ol>
<li>创建服务器：</li>
</ol>
<p>服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。</p>
<ol>
<li><strong>接收请求与响应请求</strong> 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。</li>
</ol>
<p><strong>创建 Node.js 应用</strong></p>
<p><strong>步骤一、引入</strong> <strong>required</strong> <strong>模块</strong></p>
<p>我们使用 <strong>require</strong> 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下：</p>
<p>\1. var http = require(“http”);</p>
<p><strong>步骤二、创建服务器</strong></p>
<p>接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。</p>
<p>函数通过 request, response 参数来接收和响应数据。</p>
<p>实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. var http = require(&#x27;http&#x27;);</span><br><span class="line"></span><br><span class="line">2. http.createServer(function (request, response) &#123;</span><br><span class="line"></span><br><span class="line">3.   // 发送 HTTP 头部</span><br><span class="line"></span><br><span class="line">4.   // HTTP 状态值: 200 : OK</span><br><span class="line"></span><br><span class="line">5.   // 内容类型: text/plain</span><br><span class="line"></span><br><span class="line">6.   response.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;);</span><br><span class="line"></span><br><span class="line">7.   // 发送响应数据 &quot;Hello World&quot;</span><br><span class="line"></span><br><span class="line">8.   response.end(&#x27;Hello World\n&#x27;);</span><br><span class="line"></span><br><span class="line">9. &#125;).listen(8888);</span><br><span class="line"></span><br><span class="line">10. // 终端打印如下信息</span><br><span class="line"></span><br><span class="line">11. console.log(&#x27;Server running at http://127.0.0.1:8888/&#x27;);</span><br><span class="line"></span><br><span class="line">以上代码我们完成了一个可以工作的 HTTP 服务器。</span><br></pre></td></tr></table></figure>
<p>使用 <strong>node</strong> 命令执行以上的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. node server.js</span><br><span class="line"></span><br><span class="line">2. Server running at http://127.0.0.1:8888/</span><br></pre></td></tr></table></figure>
<p>接下来，打开浏览器访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:8888/，你会看到一个写着">http://127.0.0.1:8888/，你会看到一个写着</a> “Hello World”的网页。</p>
<p><strong>分析 Node.js 的 HTTP 服务器：</strong></p>
<ul>
<li><p>第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。</p>
</li>
<li><p>接下来我们调用 http 模块提供的函数： createServer 。</p>
</li>
<li><ul>
<li>这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。</li>
</ul>
</li>
</ul>
<p><strong>NPM</strong> <strong>使用介绍</strong></p>
<p><strong>NPM</strong> <strong>使用介绍</strong></p>
<p>NPM 是随同 NodeJS 一起安装的包管理工具，能解决 NodeJS 代码部署上的很多问题，常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从 NPM 服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从 NPM 服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到 NPM 服务器供别人使用。</li>
</ul>
<p>由于新版的 nodejs 已经集成了 npm，所以之前 npm 也一并安装好了。</p>
<p>同样可以通过输入 <strong>“npm -v”</strong> 来测试是否成功安装。命令如下，出现版本提示表示安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ npm -v6.4.1</span><br></pre></td></tr></table></figure>
<p>如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. $ sudo npm install npm -g</span><br><span class="line"></span><br><span class="line">2. /usr/local/bin/npm -&gt; /usr/local/lib/node_modules/npm/bin/npm-cli.js</span><br><span class="line"></span><br><span class="line">3. npm@6.6.2 /usr/local/lib/node_modules/npm</span><br></pre></td></tr></table></figure>
<p>如果是 Window 系统使用以下命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. npm install npm -g</span><br></pre></td></tr></table></figure>
<p><strong>使用淘宝镜像</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p><strong>使用 npm 命令安装模块</strong></p>
<p>npm 安装 Node.js 模块语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ npm install</span><br></pre></td></tr></table></figure>
<p>以下实例，我们使用 npm 命令安装常用的 Node.js web 框架模块 <strong>express</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ npm install express</span><br></pre></td></tr></table></figure>
<p>安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 <strong>require(**</strong>‘express’)** 的方式就好，无需指定第三方包路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. var express = require(&#x27;express&#x27;);</span><br></pre></td></tr></table></figure>
<p><strong>全局安装与本地安装</strong></p>
<p>npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有 -g 而已，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. npm install express      # 本地安装npm install express -g    # 全局安装</span><br></pre></td></tr></table></figure>
<p>如果出现以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. npm err! Error: connect ECONNREFUSED 127.0.0.1:8087</span><br></pre></td></tr></table></figure>
<p>解决办法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ npm config set proxy null</span><br></pre></td></tr></table></figure>
<p><strong>本地安装</strong></p>
<ul>
<li><ol>
<li>将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录）</li>
</ol>
</li>
<li><ul>
<li>如果没有      node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
</ul>
</li>
<li><ol>
<li>可以通过 require() 来引入本地安装的包。</li>
</ol>
</li>
</ul>
<p><strong>全局安装</strong></p>
<ul>
<li><ol>
<li>将安装包放在 /usr/local 下或者你 node 的安装目录。</li>
</ol>
</li>
<li><ol>
<li>可以直接在命令行里使用。</li>
</ol>
</li>
</ul>
<p>如果你希望具备两者功能，则需要在两个地方安装它或使用 <a target="_blank" rel="noopener" href="https://www.axihe.com/api/npm/cli/npm-link.html"><strong>npm link</strong></a> 。</p>
<p>接下来我们使用全局方式安装 express</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ npm install express -g</span><br></pre></td></tr></table></figure>
<p>安装过程输出如下内容，第一行输出了模块的版本号及安装位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1. express@4.13.3 node_modules/express</span><br><span class="line"></span><br><span class="line">2. ├── escape-html@1.0.2</span><br><span class="line"></span><br><span class="line">3. ├── range-parser@1.0.2</span><br><span class="line"></span><br><span class="line">4. ├── merge-descriptors@1.0.0</span><br><span class="line"></span><br><span class="line">5. ├── array-flatten@1.1.1</span><br><span class="line"></span><br><span class="line">6. ├── cookie@0.1.3</span><br><span class="line"></span><br><span class="line">7. ├── utils-merge@1.0.0</span><br><span class="line"></span><br><span class="line">8. ├── parseurl@1.3.0</span><br><span class="line"></span><br><span class="line">9. ├── cookie-signature@1.0.6</span><br><span class="line"></span><br><span class="line">10. ├── methods@1.1.1</span><br><span class="line"></span><br><span class="line">11. ├── fresh@0.3.0</span><br><span class="line"></span><br><span class="line">12. ├── vary@1.0.1</span><br><span class="line"></span><br><span class="line">13. ├── path-to-regexp@0.1.7</span><br><span class="line"></span><br><span class="line">14. ├── content-type@1.0.1</span><br><span class="line"></span><br><span class="line">15. ├── etag@1.7.0</span><br><span class="line"></span><br><span class="line">16. ├── serve-static@1.10.0</span><br><span class="line"></span><br><span class="line">17. ├── content-disposition@0.5.0</span><br><span class="line"></span><br><span class="line">18. ├── depd@1.0.1</span><br><span class="line"></span><br><span class="line">19. ├── qs@4.0.0</span><br><span class="line"></span><br><span class="line">20. ├── finalhandler@0.4.0 (unpipe@1.0.0)</span><br><span class="line"></span><br><span class="line">21. ├── on-finished@2.3.0 (ee-first@1.1.1)</span><br><span class="line"></span><br><span class="line">22. ├── proxy-addr@1.0.8 (forwarded@0.1.0, ipaddr.js@1.0.1)</span><br><span class="line"></span><br><span class="line">23. ├── debug@2.2.0 (ms@0.7.1)</span><br><span class="line"></span><br><span class="line">24. ├── type-is@1.6.8 (media-typer@0.3.0, mime-types@2.1.6)</span><br><span class="line"></span><br><span class="line">25. ├── accepts@1.2.12 (negotiator@0.5.3, mime-types@2.1.6)</span><br><span class="line"></span><br><span class="line">26. └── send@0.13.0 (destroy@1.0.3, statuses@1.2.1, ms@0.7.1, mime@1.3.4, http-errors@1.3.1)</span><br></pre></td></tr></table></figure>
<p><strong>查看安装信息</strong></p>
<p>你可以使用 <strong>npm ls</strong> 命令来查看所有全局安装的模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. $ npm ls -g</span><br><span class="line"></span><br><span class="line">2. ├─┬ cnpm@4.3.2</span><br><span class="line"></span><br><span class="line">3. │ ├── auto-correct@1.0.0</span><br><span class="line"></span><br><span class="line">4. │ ├── bagpipe@0.3.5</span><br><span class="line"></span><br><span class="line">5. │ ├── colors@1.1.2</span><br><span class="line"></span><br><span class="line">6. │ ├─┬ commander@2.9.0</span><br><span class="line"></span><br><span class="line">7. │ │ └── graceful-readlink@1.0.1</span><br><span class="line"></span><br><span class="line">8. │ ├─┬ cross-spawn@0.2.9</span><br><span class="line"></span><br><span class="line">9. │ │ └── lru-cache@2.7.3</span><br><span class="line"></span><br><span class="line">10. ……</span><br></pre></td></tr></table></figure>
<p>如果要查看某个模块的版本号，可以使用命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. $ npm ls grunt</span><br><span class="line"></span><br><span class="line">2. projectName@projectVersion /path/to/project/folder</span><br><span class="line"></span><br><span class="line">3. └── grunt@0.4.1</span><br></pre></td></tr></table></figure>
<p><strong>使用 package.json</strong></p>
<p>package.json 位于模块的目录下，用于定义包的属性。</p>
<p>接下来让我们来看下 express 包的 package.json 文件，位于 node_modules/express/package.json 内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br></pre></td><td class="code"><pre><span class="line">1. &#123;</span><br><span class="line"></span><br><span class="line">2.  &quot;name&quot;: &quot;express&quot;,</span><br><span class="line"></span><br><span class="line">3.  &quot;description&quot;: &quot;Fast, unopinionated, minimalist web framework&quot;,</span><br><span class="line"></span><br><span class="line">4.  &quot;version&quot;: &quot;4.13.3&quot;,</span><br><span class="line"></span><br><span class="line">5.  &quot;author&quot;: &#123;</span><br><span class="line"></span><br><span class="line">6.   &quot;name&quot;: &quot;TJ Holowaychuk&quot;,</span><br><span class="line"></span><br><span class="line">7.   &quot;email&quot;: &quot;tj@vision-media.ca&quot;</span><br><span class="line"></span><br><span class="line">8.  &#125;,</span><br><span class="line"></span><br><span class="line">9.  &quot;contributors&quot;: [</span><br><span class="line"></span><br><span class="line">10.   &#123;</span><br><span class="line"></span><br><span class="line">11.    &quot;name&quot;: &quot;Aaron Heckmann&quot;,</span><br><span class="line"></span><br><span class="line">12.    &quot;email&quot;: &quot;aaron.heckmann+github@gmail.com&quot;</span><br><span class="line"></span><br><span class="line">13.   &#125;,</span><br><span class="line"></span><br><span class="line">14.   &#123;</span><br><span class="line"></span><br><span class="line">15.    &quot;name&quot;: &quot;Ciaran Jessup&quot;,</span><br><span class="line"></span><br><span class="line">16.    &quot;email&quot;: &quot;ciaranj@gmail.com&quot;</span><br><span class="line"></span><br><span class="line">17.   &#125;,</span><br><span class="line"></span><br><span class="line">18.   &#123;</span><br><span class="line"></span><br><span class="line">19.    &quot;name&quot;: &quot;Douglas Christopher Wilson&quot;,</span><br><span class="line"></span><br><span class="line">20.    &quot;email&quot;: &quot;doug@somethingdoug.com&quot;</span><br><span class="line"></span><br><span class="line">21.   &#125;,</span><br><span class="line"></span><br><span class="line">22.   &#123;</span><br><span class="line"></span><br><span class="line">23.    &quot;name&quot;: &quot;Guillermo Rauch&quot;,</span><br><span class="line"></span><br><span class="line">24.    &quot;email&quot;: &quot;rauchg@gmail.com&quot;</span><br><span class="line"></span><br><span class="line">25.   &#125;,</span><br><span class="line"></span><br><span class="line">26.   &#123;</span><br><span class="line"></span><br><span class="line">27.    &quot;name&quot;: &quot;Jonathan Ong&quot;,</span><br><span class="line"></span><br><span class="line">28.    &quot;email&quot;: &quot;me@jongleberry.com&quot;</span><br><span class="line"></span><br><span class="line">29.   &#125;,</span><br><span class="line"></span><br><span class="line">30.   &#123;</span><br><span class="line"></span><br><span class="line">31.    &quot;name&quot;: &quot;Roman Shtylman&quot;,</span><br><span class="line"></span><br><span class="line">32.    &quot;email&quot;: &quot;shtylman+expressjs@gmail.com&quot;</span><br><span class="line"></span><br><span class="line">33.   &#125;,</span><br><span class="line"></span><br><span class="line">34.   &#123;</span><br><span class="line"></span><br><span class="line">35.    &quot;name&quot;: &quot;Young Jae Sim&quot;,</span><br><span class="line"></span><br><span class="line">36.    &quot;email&quot;: &quot;hanul@hanul.me&quot;</span><br><span class="line"></span><br><span class="line">37.   &#125;</span><br><span class="line"></span><br><span class="line">38.  ],</span><br><span class="line"></span><br><span class="line">39.  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line"></span><br><span class="line">40.  &quot;repository&quot;: &#123;</span><br><span class="line"></span><br><span class="line">41.   &quot;type&quot;: &quot;git&quot;,</span><br><span class="line"></span><br><span class="line">42.   &quot;url&quot;: &quot;git+https://github.com/strongloop/express.git&quot;</span><br><span class="line"></span><br><span class="line">43.  &#125;,</span><br><span class="line"></span><br><span class="line">44.  &quot;homepage&quot;: &quot;http://expressjs.com/&quot;,</span><br><span class="line"></span><br><span class="line">45.  &quot;keywords&quot;: [</span><br><span class="line"></span><br><span class="line">46.   &quot;express&quot;,</span><br><span class="line"></span><br><span class="line">47.   &quot;framework&quot;,</span><br><span class="line"></span><br><span class="line">48.   &quot;sinatra&quot;,</span><br><span class="line"></span><br><span class="line">49.   &quot;web&quot;,</span><br><span class="line"></span><br><span class="line">50.   &quot;rest&quot;,</span><br><span class="line"></span><br><span class="line">51.   &quot;restful&quot;,</span><br><span class="line"></span><br><span class="line">52.   &quot;router&quot;,</span><br><span class="line"></span><br><span class="line">53.   &quot;app&quot;,</span><br><span class="line"></span><br><span class="line">54.   &quot;api&quot;</span><br><span class="line"></span><br><span class="line">55.  ],</span><br><span class="line"></span><br><span class="line">56.  &quot;dependencies&quot;: &#123;</span><br><span class="line"></span><br><span class="line">57.   &quot;accepts&quot;: &quot;~1.2.12&quot;,</span><br><span class="line"></span><br><span class="line">58.   &quot;array-flatten&quot;: &quot;1.1.1&quot;,</span><br><span class="line"></span><br><span class="line">59.   &quot;content-disposition&quot;: &quot;0.5.0&quot;,</span><br><span class="line"></span><br><span class="line">60.   &quot;content-type&quot;: &quot;~1.0.1&quot;,</span><br><span class="line"></span><br><span class="line">61.   &quot;cookie&quot;: &quot;0.1.3&quot;,</span><br><span class="line"></span><br><span class="line">62.   &quot;cookie-signature&quot;: &quot;1.0.6&quot;,</span><br><span class="line"></span><br><span class="line">63.   &quot;debug&quot;: &quot;~2.2.0&quot;,</span><br><span class="line"></span><br><span class="line">64.   &quot;depd&quot;: &quot;~1.0.1&quot;,</span><br><span class="line"></span><br><span class="line">65.   &quot;escape-html&quot;: &quot;1.0.2&quot;,</span><br><span class="line"></span><br><span class="line">66.   &quot;etag&quot;: &quot;~1.7.0&quot;,</span><br><span class="line"></span><br><span class="line">67.   &quot;finalhandler&quot;: &quot;0.4.0&quot;,</span><br><span class="line"></span><br><span class="line">68.   &quot;fresh&quot;: &quot;0.3.0&quot;,</span><br><span class="line"></span><br><span class="line">69.   &quot;merge-descriptors&quot;: &quot;1.0.0&quot;,</span><br><span class="line"></span><br><span class="line">70.   &quot;methods&quot;: &quot;~1.1.1&quot;,</span><br><span class="line"></span><br><span class="line">71.   &quot;on-finished&quot;: &quot;~2.3.0&quot;,</span><br><span class="line"></span><br><span class="line">72.   &quot;parseurl&quot;: &quot;~1.3.0&quot;,</span><br><span class="line"></span><br><span class="line">73.   &quot;path-to-regexp&quot;: &quot;0.1.7&quot;,</span><br><span class="line"></span><br><span class="line">74.   &quot;proxy-addr&quot;: &quot;~1.0.8&quot;,</span><br><span class="line"></span><br><span class="line">75.   &quot;qs&quot;: &quot;4.0.0&quot;,</span><br><span class="line"></span><br><span class="line">76.   &quot;range-parser&quot;: &quot;~1.0.2&quot;,</span><br><span class="line"></span><br><span class="line">77.   &quot;send&quot;: &quot;0.13.0&quot;,</span><br><span class="line"></span><br><span class="line">78.   &quot;serve-static&quot;: &quot;~1.10.0&quot;,</span><br><span class="line"></span><br><span class="line">79.   &quot;type-is&quot;: &quot;~1.6.6&quot;,</span><br><span class="line"></span><br><span class="line">80.   &quot;utils-merge&quot;: &quot;1.0.0&quot;,</span><br><span class="line"></span><br><span class="line">81.   &quot;vary&quot;: &quot;~1.0.1&quot;</span><br><span class="line"></span><br><span class="line">82.  &#125;,</span><br><span class="line"></span><br><span class="line">83.  &quot;devDependencies&quot;: &#123;</span><br><span class="line"></span><br><span class="line">84.   &quot;after&quot;: &quot;0.8.1&quot;,</span><br><span class="line"></span><br><span class="line">85.   &quot;ejs&quot;: &quot;2.3.3&quot;,</span><br><span class="line"></span><br><span class="line">86.   &quot;istanbul&quot;: &quot;0.3.17&quot;,</span><br><span class="line"></span><br><span class="line">87.   &quot;marked&quot;: &quot;0.3.5&quot;,</span><br><span class="line"></span><br><span class="line">88.   &quot;mocha&quot;: &quot;2.2.5&quot;,</span><br><span class="line"></span><br><span class="line">89.   &quot;should&quot;: &quot;7.0.2&quot;,</span><br><span class="line"></span><br><span class="line">90.   &quot;supertest&quot;: &quot;1.0.1&quot;,</span><br><span class="line"></span><br><span class="line">91.   &quot;body-parser&quot;: &quot;~1.13.3&quot;,</span><br><span class="line"></span><br><span class="line">92.   &quot;connect-redis&quot;: &quot;~2.4.1&quot;,</span><br><span class="line"></span><br><span class="line">93.   &quot;cookie-parser&quot;: &quot;~1.3.5&quot;,</span><br><span class="line"></span><br><span class="line">94.   &quot;cookie-session&quot;: &quot;~1.2.0&quot;,</span><br><span class="line"></span><br><span class="line">95.   &quot;express-session&quot;: &quot;~1.11.3&quot;,</span><br><span class="line"></span><br><span class="line">96.   &quot;jade&quot;: &quot;~1.11.0&quot;,</span><br><span class="line"></span><br><span class="line">97.   &quot;method-override&quot;: &quot;~2.3.5&quot;,</span><br><span class="line"></span><br><span class="line">98.   &quot;morgan&quot;: &quot;~1.6.1&quot;,</span><br><span class="line"></span><br><span class="line">99.   &quot;multiparty&quot;: &quot;~4.1.2&quot;,</span><br><span class="line"></span><br><span class="line">100.   &quot;vhost&quot;: &quot;~3.0.1&quot;</span><br><span class="line"></span><br><span class="line">101.  &#125;,</span><br><span class="line"></span><br><span class="line">102.  &quot;engines&quot;: &#123;</span><br><span class="line"></span><br><span class="line">103.   &quot;node&quot;: &quot;&gt;= 0.10.0&quot;</span><br><span class="line"></span><br><span class="line">104.  &#125;,</span><br><span class="line"></span><br><span class="line">105.  &quot;files&quot;: [</span><br><span class="line"></span><br><span class="line">106.   &quot;LICENSE&quot;,</span><br><span class="line"></span><br><span class="line">107.   &quot;History.md&quot;,</span><br><span class="line"></span><br><span class="line">108.   &quot;Readme.md&quot;,</span><br><span class="line"></span><br><span class="line">109.   &quot;index.js&quot;,</span><br><span class="line"></span><br><span class="line">110.   &quot;lib/&quot;</span><br><span class="line"></span><br><span class="line">111.  ],</span><br><span class="line"></span><br><span class="line">112.  &quot;scripts&quot;: &#123;</span><br><span class="line"></span><br><span class="line">113.   &quot;test&quot;: &quot;mocha --require test/support/env --reporter spec --bail --check-leaks test/ test/acceptance/&quot;,</span><br><span class="line"></span><br><span class="line">114.   &quot;test-ci&quot;: &quot;istanbul cover node_modules/mocha/bin/_mocha --report lcovonly -- --require test/support/env --reporter spec --check-leaks test/ test/acceptance/&quot;,</span><br><span class="line"></span><br><span class="line">115.   &quot;test-cov&quot;: &quot;istanbul cover node_modules/mocha/bin/_mocha -- --require test/support/env --reporter dot --check-leaks test/ test/acceptance/&quot;,</span><br><span class="line"></span><br><span class="line">116.   &quot;test-tap&quot;: &quot;mocha --require test/support/env --reporter tap --check-leaks test/ test/acceptance/&quot;</span><br><span class="line"></span><br><span class="line">117.  &#125;,</span><br><span class="line"></span><br><span class="line">118.  &quot;gitHead&quot;: &quot;ef7ad681b245fba023843ce94f6bcb8e275bbb8e&quot;,</span><br><span class="line"></span><br><span class="line">119.  &quot;bugs&quot;: &#123;</span><br><span class="line"></span><br><span class="line">120.   &quot;url&quot;: &quot;https://github.com/strongloop/express/issues&quot;</span><br><span class="line"></span><br><span class="line">121.  &#125;,</span><br><span class="line"></span><br><span class="line">122.  &quot;_id&quot;: &quot;express@4.13.3&quot;,</span><br><span class="line"></span><br><span class="line">123.  &quot;_shasum&quot;: &quot;ddb2f1fb4502bf33598d2b032b037960ca6c80a3&quot;,</span><br><span class="line"></span><br><span class="line">124.  &quot;_from&quot;: &quot;express@*&quot;,</span><br><span class="line"></span><br><span class="line">125.  &quot;_npmVersion&quot;: &quot;1.4.28&quot;,</span><br><span class="line"></span><br><span class="line">126.  &quot;_npmUser&quot;: &#123;</span><br><span class="line"></span><br><span class="line">127.   &quot;name&quot;: &quot;dougwilson&quot;,</span><br><span class="line"></span><br><span class="line">128.   &quot;email&quot;: &quot;doug@somethingdoug.com&quot;</span><br><span class="line"></span><br><span class="line">129.  &#125;,</span><br><span class="line"></span><br><span class="line">130.  &quot;maintainers&quot;: [</span><br><span class="line"></span><br><span class="line">131.   &#123;</span><br><span class="line"></span><br><span class="line">132.    &quot;name&quot;: &quot;tjholowaychuk&quot;,</span><br><span class="line"></span><br><span class="line">133.    &quot;email&quot;: &quot;tj@vision-media.ca&quot;</span><br><span class="line"></span><br><span class="line">134.   &#125;,</span><br><span class="line"></span><br><span class="line">135.   &#123;</span><br><span class="line"></span><br><span class="line">136.    &quot;name&quot;: &quot;jongleberry&quot;,</span><br><span class="line"></span><br><span class="line">137.    &quot;email&quot;: &quot;jonathanrichardong@gmail.com&quot;</span><br><span class="line">138.   &#125;,</span><br><span class="line">139.   &#123;</span><br><span class="line">140.    &quot;name&quot;: &quot;dougwilson&quot;,</span><br><span class="line">141.    &quot;email&quot;: &quot;doug@somethingdoug.com&quot;</span><br><span class="line">142.   &#125;,</span><br><span class="line">143.   &#123;</span><br><span class="line">144.    &quot;name&quot;: &quot;rfeng&quot;,</span><br><span class="line">145.    &quot;email&quot;: &quot;enjoyjava@gmail.com&quot;</span><br><span class="line">146.   &#125;,</span><br><span class="line">147.   &#123;</span><br><span class="line">148.    &quot;name&quot;: &quot;aredridel&quot;,</span><br><span class="line"></span><br><span class="line">149.    &quot;email&quot;: &quot;aredridel@dinhe.net&quot;</span><br><span class="line">150.   &#125;,</span><br><span class="line">151.   &#123;</span><br><span class="line">152.    &quot;name&quot;: &quot;strongloop&quot;,</span><br><span class="line">153.    &quot;email&quot;: &quot;callback@strongloop.com&quot;</span><br><span class="line">154.   &#125;,</span><br><span class="line">155.   &#123;</span><br><span class="line">156.    &quot;name&quot;: &quot;defunctzombie&quot;,</span><br><span class="line">155.    &quot;email&quot;: &quot;shtylman@gmail.com&quot;</span><br><span class="line"></span><br><span class="line">158.   &#125;</span><br><span class="line"></span><br><span class="line">159.  ],</span><br><span class="line"></span><br><span class="line">160.  &quot;dist&quot;: &#123;</span><br><span class="line"></span><br><span class="line">161.   &quot;shasum&quot;: &quot;ddb2f1fb4502bf33598d2b032b037960ca6c80a3&quot;,</span><br><span class="line"></span><br><span class="line">162.   &quot;tarball&quot;: &quot;http://registry.npmjs.org/express/-/express-4.13.3.tgz&quot;</span><br><span class="line"></span><br><span class="line">163.  &#125;,</span><br><span class="line"></span><br><span class="line">164.  &quot;directories&quot;: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">165.  &quot;_resolved&quot;: &quot;https://registry.npmjs.org/express/-/express-4.13.3.tgz&quot;,</span><br><span class="line"></span><br><span class="line">166.  &quot;readme&quot;: &quot;ERROR: No README data found!&quot;</span><br><span class="line"></span><br><span class="line">167. &#125;</span><br></pre></td></tr></table></figure>
<p><strong>Package.json</strong> <strong>属性说明</strong></p>
<ul>
<li><strong>name</strong> - 包名。</li>
<li><strong>version</strong> - 包的版本号。</li>
<li><strong>description</strong> - 包的描述。</li>
<li><strong>homepage</strong> - 包的官网 url 。</li>
<li><strong>author</strong> - 包的作者姓名。</li>
<li><strong>contributors</strong> - 包的其他贡献者姓名。</li>
<li><strong>dependencies</strong> - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</li>
<li><strong>repository</strong> - 包代码存放的地方的类型，可以是 git 或 svn，git 可在     Github 上。</li>
<li><strong>main</strong> - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。</li>
<li><strong>keywords</strong> - 关键字</li>
</ul>
<p><strong>卸载模块</strong></p>
<p>我们可以使用 npm uninstall 来卸载 Node.js 模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ npm uninstall express</span><br></pre></td></tr></table></figure>
<p>卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ npm ls</span><br></pre></td></tr></table></figure>
<p><strong>更新模块</strong></p>
<p>我们可以使用 npm update更新模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ npm update express</span><br></pre></td></tr></table></figure>
<p><strong>搜索模块</strong></p>
<p>使用 npm search来搜索模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ npm search express</span><br></pre></td></tr></table></figure>
<p><strong>创建模块</strong></p>
<p>创建模块，package.json 文件是必不可少的。</p>
<p>我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. $ npm init</span><br><span class="line">2. This utility will walk you through creating a package.json file.</span><br><span class="line">3. It only covers the most common items, and tries to guess sensible defaults.</span><br><span class="line">4. See `npm help json` for definitive documentation on these fields</span><br><span class="line">5. and exactly what they do.</span><br><span class="line">6. Use `npm install --save` afterwards to install a package and</span><br><span class="line">7. save it as a dependency in the package.json file.</span><br><span class="line">8. Press ^C at any time to quit.</span><br><span class="line">9. name: (node_modules) axihe          # 模块名</span><br><span class="line">10. version: (1.0.0)</span><br><span class="line">11. description: Node.js 测试模块(www.axihe.com) # 描述</span><br><span class="line">12. entry point: (index.js)</span><br><span class="line">13. test command: make test</span><br><span class="line">14. git repository: https://github.com/axihe/axihe.git # Github 地址</span><br><span class="line">15. keywords:</span><br><span class="line">16. author:</span><br><span class="line">17. license: (ISC)</span><br><span class="line">18. About to write to ……/node_modules/package.json:   # 生成地址</span><br><span class="line">19. &#123;</span><br><span class="line">20.  &quot;name&quot;: &quot;axihe&quot;,</span><br><span class="line">21.  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">22.  &quot;description&quot;: &quot;Node.js 测试模块(www.axihe.com)&quot;,</span><br><span class="line">23.  ……</span><br><span class="line">24. &#125;</span><br><span class="line">25. Is this ok? (yes) yes</span><br></pre></td></tr></table></figure>
<p>以上的信息，你需要根据你自己的情况输入。在最后输入 “yes” 后会生成 package.json 文件。</p>
<p>接下来我们可以使用 npm adduser 在 npm 资源库中注册用户（使用邮箱注册）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ npm adduserUsername: mcmohdPassword:Email: (this IS public) mcmohd@gmail.com</span><br></pre></td></tr></table></figure>
<p>接下来我们就用 npm publishl来发布模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ npm publish</span><br></pre></td></tr></table></figure>
<p>如果你以上的步骤都操作正确，你就可以跟其他模块一样使用 npm 来安装。</p>
<p><strong>版本号</strong></p>
<p>使用 NPM 下载和发布代码时都会接触到版本号。</p>
<p>NPM 使用语义版本号来管理代码，这里简单介绍一下。</p>
<p>语义版本号分为 X.Y.Z 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p>
<ul>
<li>如果只是修复 bug，需要更新 Z 位。</li>
<li>如果是新增了功能，但是向下兼容，需要更新 Y 位。</li>
<li>如果有大变动，向下不兼容，需要更新 X 位。</li>
</ul>
<p>版本号有了这个保证后，在申明第三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。</p>
<p>例如”argv”: “0.0.x”表示依赖于 0.0.x 系列的最新版 argv。</p>
<p><strong>NPM</strong> <strong>常用命令</strong></p>
<p>NPM 还提供了很多功能，package.json 里也有很多其它有用的字段。</p>
<p>介绍一些NPM常用命令。</p>
<p>NPM 提供了很多命令，例如 install 和 publish，使用 npm help 可查看所有命令。</p>
<ul>
<li>NPM 提供了很多命令，例如install和publish，使用npm help可查看所有命令。</li>
<li>使用npm help 可查看某条命令的详细帮助，例如npm help install。</li>
<li>在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。</li>
<li>使用npm update 可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。</li>
<li>使用npm update -g可以把全局安装的对应命令行程序更新至最新版。</li>
<li>使用npm cache clear可以清空 NPM 本地缓存，用于对付使用相同版本号发布新版本代码的人。</li>
<li>使用npm unpublish @可以撤销发布自己发布过的某个版本代码。</li>
</ul>
<p><strong>使用淘宝 NPM 镜像</strong></p>
<p>国内直接使用 npm 的官方镜像，如果网络不怎么给力是非常慢的，这里推荐使用淘宝 NPM 镜像。</p>
<p>淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本（只读），同步频率目前为 10 分钟 一次以保证尽量与官方服务同步。</p>
<p>你可以使用淘宝定制的 cnpm (gzip 压缩支持） 命令行工具代替默认的 npm:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>这样就可以使用 cnpm 命令来安装模块了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ cnpm install [name]</span><br></pre></td></tr></table></figure>
<p>更多信息可以查阅：<a target="_blank" rel="noopener" href="http://npm.taobao.org/。">http://npm.taobao.org/。</a></p>
<p><strong>nrm</strong> <strong>管理镜像</strong></p>
<p>更加推荐使用 nrm 来控制 npm 的源</p>
<p>他可以一条命令切到淘宝 / 网易 /XXX 的源，也可以一条命令切回官方源头，这让我觉得特别给力，特别是我需要发我自己制作的 npm 包的时候；</p>
<p><strong>Node.js REPL**</strong>（交互式解释器）**</p>
<p><strong>Node.js REPL**</strong>（交互式解释器）**</p>
<p>Node.js REPL(Read Eval Print Loop: 交互式解释器） 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。</p>
<p>Node 自带了交互式解释器，可以执行以下任务：</p>
<ul>
<li><strong>读取（Read）</strong> - 读取用户输入，解析输入了 Javascript 数据结构并存储在内存中。</li>
<li><strong>执行（Eval）</strong> - 执行输入的数据结构</li>
<li><strong>打印（Print）</strong> - 输出结果</li>
<li><strong>循环（Loop）</strong> - 循环操作以上步骤直到用户两次按下 <strong>ctrl-c</strong> 按钮退出。</li>
</ul>
<p>Node 的交互式解释器可以很好的调试 Javascript 代码。</p>
<p>开始学习 REPL</p>
<p>我们可以输入以下命令来启动 Node 的终端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ node&gt;</span><br></pre></td></tr></table></figure>
<p>这时我们就可以在 &gt; 后输入简单的表达式，并按下回车键来计算结果。</p>
<p><strong>简单的表达式运算</strong></p>
<p>接下来让我们在 Node.js REPL 的命令行窗口中执行简单的数学运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. $ node</span><br><span class="line">2. &gt; 1 +4</span><br><span class="line">3. 5</span><br><span class="line">4. &gt; 5 / 2</span><br><span class="line">5. 2.5</span><br><span class="line">6. &gt; 3 * 6</span><br><span class="line">7. 18</span><br><span class="line">8. &gt; 4 - 1</span><br><span class="line">9. 3</span><br><span class="line">10. &gt; 1 + ( 2 * 3 ) - 4</span><br><span class="line">11. 3</span><br><span class="line">12. &gt; </span><br></pre></td></tr></table></figure>
<p><strong>使用变量</strong></p>
<p>你可以将数据存储在变量中，并在你需要的时候使用它。</p>
<p>变量声明需要使用 <strong>var</strong> 关键字，如果没有使用 var 关键字变量会直接打印出来。</p>
<p>使用 <strong>var</strong> 关键字的变量可以使用 console.log() 来输出变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. $ node</span><br><span class="line">2. &gt; x = 10</span><br><span class="line">3. 10</span><br><span class="line">4. &gt; var y = 10</span><br><span class="line">5. undefined</span><br><span class="line">6. &gt; x + y</span><br><span class="line">7. 20</span><br><span class="line">8. &gt; console.log(&quot;Hello World&quot;)</span><br><span class="line">9. Hello World</span><br><span class="line">10. undefined</span><br><span class="line">11. &gt; console.log(&quot;www.codecheng.com&quot;)</span><br><span class="line">12. www.codecheng.com</span><br><span class="line">13. undefined</span><br></pre></td></tr></table></figure>
<p><strong>多行表达式</strong></p>
<p>Node REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. $ node</span><br><span class="line">2. &gt; var x = 0</span><br><span class="line">3. undefined</span><br><span class="line">4. &gt; do &#123;</span><br><span class="line">5. ... x++;</span><br><span class="line">6. ... console.log(&quot;x: &quot; + x);</span><br><span class="line">7. ... &#125; while ( x &lt; 5 );</span><br><span class="line">8. x: 1</span><br><span class="line">9. x: 2</span><br><span class="line">10. x: 3</span><br><span class="line">11. x: 4</span><br><span class="line">12. x: 5</span><br><span class="line">13. undefined</span><br><span class="line">14. &gt; </span><br></pre></td></tr></table></figure>
<p><strong>…</strong> 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。</p>
<p><strong>下划线</strong> <strong>(_)</strong> <strong>变量</strong></p>
<p>你可以使用下划线 (_) 获取上一个表达式的运算结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. $ node</span><br><span class="line">2. &gt; var x = 10</span><br><span class="line">3. undefined</span><br><span class="line">4. &gt; var y = 20</span><br><span class="line">5. undefined</span><br><span class="line">6. &gt; x + y</span><br><span class="line">7. 30</span><br><span class="line">8. &gt; var sum = _</span><br><span class="line">9. undefined</span><br><span class="line">10. &gt; console.log(sum)</span><br><span class="line">11. 30</span><br><span class="line">12. undefined</span><br><span class="line">13. &gt; </span><br></pre></td></tr></table></figure>
<p><strong>REPL</strong> <strong>命令</strong></p>
<ul>
<li><strong>ctrl + c</strong> - 退出当前终端。</li>
<li><strong>ctrl + c</strong> <strong>按下两次</strong> - 退出 Node REPL。</li>
<li><strong>ctrl + d</strong> - 退出 Node REPL.</li>
<li><strong>向上 / 向下 键</strong> - 查看输入的历史命令</li>
<li><strong>tab</strong> <strong>键</strong> - 列出当前命令</li>
<li><strong>.help</strong> - 列出使用命令</li>
<li><strong>.break</strong> - 退出多行表达式</li>
<li><strong>.clear</strong> - 退出多行表达式</li>
<li><strong>.save *filename*</strong> - 保存当前的 Node REPL 会话到指定文件</li>
<li><strong>.load *filename*</strong> - 载入当前 Node REPL 会话的文件内容。</li>
</ul>
<p><strong>停止 REPL</strong></p>
<p>前面我们已经提到按下两次 <strong>ctrl + c</strong> 键就能退出 REPL:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ node&gt;(^C again to quit)&gt;</span><br></pre></td></tr></table></figure>
<p><strong>Node.js</strong> <strong>回调函数</strong></p>
<p><strong>Node.js</strong> <strong>回调函数</strong></p>
<p>Node.js 异步编程的直接体现就是回调。</p>
<p>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。</p>
<p>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p>
<p>例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。</p>
<p>回调函数一般作为函数的最后一个参数出现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. function foo1(name, age, callback) &#123; &#125;</span><br><span class="line"></span><br><span class="line">2. function foo2(value, callback1, callback2) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>阻塞代码实例</strong></p>
<p>创建一个文件 input.txt ，内容如下：</p>
<ol>
<li>我的博客地址：www.mrschen.top</li>
</ol>
<p>创建 main.js 文件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. var fs = require(&quot;fs&quot;);</span><br><span class="line">2. var data = fs.readFileSync(&#x27;input.txt&#x27;);</span><br><span class="line">3. console.log(data.toString());</span><br><span class="line">4. console.log(&quot;程序执行结束!&quot;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. $ node main.js</span><br><span class="line">2. 我的博客地址：www.mrschen.top</span><br><span class="line">3. 程序执行结束!</span><br></pre></td></tr></table></figure>
<p><strong>非阻塞代码实例</strong></p>
<p>创建一个文件 input.txt ，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 我的博客地址：www.mrschen.top</span><br></pre></td></tr></table></figure>
<p>创建 main.js 文件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. var fs = require(&quot;fs&quot;);</span><br><span class="line">2. fs.readFile(&#x27;input.txt&#x27;, function (err, data) &#123;</span><br><span class="line">3.   if (err) return console.error(err);</span><br><span class="line">4.   console.log(data.toString());</span><br><span class="line">5. &#125;);</span><br><span class="line">6. console.log(&quot;程序执行结束!&quot;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. $ node main.js</span><br><span class="line">2. 程序执行结束!</span><br><span class="line">3. 我的博客地址：www.mrschen.top</span><br></pre></td></tr></table></figure>
<p>以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。</p>
<p>因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。</p>
<p><strong>Node.js</strong> <strong>事件循环</strong></p>
<p><strong>Node.js</strong> <strong>事件循环</strong></p>
<p>Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。</p>
<p>Node.js 几乎每一个 API 都是支持回调函数的。</p>
<p>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。</p>
<p>Node.js 单线程类似进入一个 while(true) 的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数。</p>
<p><strong>事件驱动程序</strong></p>
<p>Node.js 使用事件驱动模型，当 web server 接收到请求，就把它关闭然后进行处理，然后去服务下一个 web 请求。</p>
<p>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p>
<p>这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式 IO 或者事件驱动 IO）</p>
<p>在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p>
<p><img src="C:\Users\86133\Pictures\node11.jpg" alt="img"></p>
<p>整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题 (Subject)，而所有注册到这个事件上的处理函数相当于观察者 (Observer)。</p>
<p>Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. // 引入 events 模块</span><br><span class="line">2. var events = require(&#x27;events&#x27;);</span><br><span class="line">3. // 创建 eventEmitter 对象</span><br><span class="line">4. var eventEmitter = new events.EventEmitter();</span><br></pre></td></tr></table></figure>
<p>以下程序绑定事件处理程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. // 绑定事件及事件的处理程序</span><br><span class="line">2. eventEmitter.on(&#x27;eventName&#x27;, eventHandler);</span><br></pre></td></tr></table></figure>
<p>我们可以通过程序触发事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. // 触发事件eventEmitter.emit(&#x27;eventName&#x27;);</span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<p>创建 main.js 文件，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. // 引入 events 模块</span><br><span class="line">2. var events = require(&#x27;events&#x27;);</span><br><span class="line">3. // 创建 eventEmitter 对象</span><br><span class="line">4. var eventEmitter = new events.EventEmitter();</span><br><span class="line">5. // 创建事件处理程序</span><br><span class="line">6. var connectHandler = function connected() &#123;</span><br><span class="line">7.   console.log(&#x27;连接成功。&#x27;);</span><br><span class="line">8.   // 触发 data_received 事件</span><br><span class="line">9.   eventEmitter.emit(&#x27;data_received&#x27;);</span><br><span class="line">10. &#125;</span><br><span class="line">11. // 绑定 connection 事件处理程序</span><br><span class="line">12. eventEmitter.on(&#x27;connection&#x27;, connectHandler);</span><br><span class="line">13. // 使用匿名函数绑定 data_received 事件</span><br><span class="line">14. eventEmitter.on(&#x27;data_received&#x27;, function()&#123;</span><br><span class="line">15.   console.log(&#x27;数据接收成功。&#x27;);</span><br><span class="line">16. &#125;);</span><br><span class="line">17. // 触发 connection 事件</span><br><span class="line">18. eventEmitter.emit(&#x27;connection&#x27;);</span><br><span class="line">19. console.log(&quot;程序执行完毕。&quot;);</span><br></pre></td></tr></table></figure>
<p>接下来让我们执行以上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. $ node main.js</span><br><span class="line">2. 连接成功。</span><br><span class="line">3. 数据接收成功。</span><br><span class="line">4. 程序执行完毕。</span><br></pre></td></tr></table></figure>
<p><strong>Node</strong> <strong>应用程序是如何工作的？</strong></p>
<p>在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。</p>
<p>接下来让我们来重新看下前面的实例，创建一个 input.txt , 文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\1. 我的博客地址：www.mrschen.top</span><br><span class="line"></span><br><span class="line">创建 main.js 文件，代码如下：</span><br><span class="line"></span><br><span class="line">1. var fs = require(&quot;fs&quot;);</span><br><span class="line">2.fs.readFile(&#x27;input.txt&#x27;, function (err, data) &#123;</span><br><span class="line">3.if (err)&#123;</span><br><span class="line">4.console.log(err.stack);</span><br><span class="line">5.return;</span><br><span class="line">6. &#125;</span><br><span class="line">7. console.log(data.toString());</span><br><span class="line">8. &#125;);</span><br><span class="line">9. console.log(&quot;程序执行完毕&quot;);</span><br></pre></td></tr></table></figure>
<p>以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。</p>
<p>如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。</p>
<p>执行以上代码，执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 我的博客地址：www.mrschen.top</span><br></pre></td></tr></table></figure>
<p>接下来我们删除 input.txt 文件，执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 程序执行完毕Error: ENOENT, open &#x27;input.txt&#x27;</span><br></pre></td></tr></table></figure>
<p>因为文件 input.txt 不存在，所以输出了错误信息。</p>
<p><strong>Node.js EventEmitter</strong></p>
<p><strong>Node.js EventEmitter</strong></p>
<p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p>
<p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p>
<p><strong>EventEmitter</strong> <strong>类</strong></p>
<p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p>
<p>你可以通过 require(“events”); 来访问该模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. // 引入 events 模块</span><br><span class="line">2. var events = require(&#x27;events&#x27;);</span><br><span class="line">3. // 创建 eventEmitter 对象</span><br><span class="line">4. var eventEmitter = new events.EventEmitter();</span><br></pre></td></tr></table></figure>
<p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p>
<p>下面我们用一个简单的例子说明 EventEmitter 的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. //event.js 文件</span><br><span class="line">2. var EventEmitter = require(&#x27;events&#x27;).EventEmitter;</span><br><span class="line">3. var event = new EventEmitter();</span><br><span class="line">4. event.on(&#x27;some_event&#x27;, function() &#123;</span><br><span class="line">5.   console.log(&#x27;some_event 事件触发&#x27;);</span><br><span class="line">6. &#125;);</span><br><span class="line">7. setTimeout(function() &#123;</span><br><span class="line">8.   event.emit(&#x27;some_event&#x27;);</span><br><span class="line">9. &#125;, 1000);</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p>运行这段代码，1 秒后控制台输出了 <strong>‘some_event 事件触发’</strong>。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用 some_event 的监听器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. $ node event.js</span><br><span class="line">2. some_event 事件触发</span><br></pre></td></tr></table></figure>
<p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p>
<p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>
<p>让我们以下面的例子解释这个过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. //event.js 文件</span><br><span class="line">2. var events = require(&#x27;events&#x27;);</span><br><span class="line">3. var emitter = new events.EventEmitter();</span><br><span class="line">4. emitter.on(&#x27;someEvent&#x27;, function(arg1, arg2) &#123;</span><br><span class="line">5.console.log(&#x27;listener1&#x27;, arg1, arg2);</span><br><span class="line">6. &#125;);</span><br><span class="line">7. emitter.on(&#x27;someEvent&#x27;, function(arg1, arg2) &#123;</span><br><span class="line">8.console.log(&#x27;listener2&#x27;, arg1, arg2);</span><br><span class="line">9. &#125;);</span><br><span class="line">10. emitter.emit(&#x27;someEvent&#x27;, &#x27;arg1 参数&#x27;, &#x27;arg2 参数&#x27;);</span><br></pre></td></tr></table></figure>
<p>执行以上代码，运行的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. $ node event.js</span><br><span class="line">2. listener1 arg1 参数 arg2 参数</span><br><span class="line">3. listener2 arg1 参数 arg2 参数</span><br></pre></td></tr></table></figure>
<p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p>
<p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是 EventEmitter 最简单的用法。</p>
<p>EventEmitter 提供了多个属性，如 <strong>on</strong> 和 <strong>emit</strong>。<strong>on</strong> 函数用于绑定事件函数，<strong>emit</strong> 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p>
<p><strong>方法</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法 &amp; 描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>addListener(event, listener)</strong> 为指定事件添加一个监听器到监听器数组的尾部。</td>
</tr>
<tr>
<td>2</td>
<td><strong>on(event, listener)</strong> 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。server.on(‘connection’,  function (stream) { console.log(‘someone connected!’);});</td>
</tr>
<tr>
<td>3</td>
<td><strong>once(event, listener)</strong> 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。server.once(‘connection’, function (stream) {  console.log(‘Ah, we have our first user!’);});</td>
</tr>
<tr>
<td>4</td>
<td><strong>removeListener(event, listener)</strong> 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。var callback = function(stream) { console.log(‘someone  connected!’);};server.on(‘connection’, callback);//  …server.removeListener(‘connection’, callback);</td>
</tr>
<tr>
<td>5</td>
<td><strong>removeAllListeners([event])</strong> 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</td>
</tr>
<tr>
<td>6</td>
<td><strong>setMaxListeners(n)</strong> 默认情况下，  EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</td>
</tr>
<tr>
<td>7</td>
<td><strong>listeners(event)</strong> 返回指定事件的监听器数组。</td>
</tr>
<tr>
<td>8</td>
<td><strong>emit(event, [arg1], [arg2], […])</strong> 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>类方法</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法 &amp; 描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>listenerCount(emitter, event)</strong> 返回指定事件的监听器数量。</td>
</tr>
</tbody>
</table>
</div>
<p>\1. events.EventEmitter.listenerCount(emitter, eventName) //已废弃，不推荐events.emitter.listenerCount(eventName) //推荐</p>
<p><strong>事件</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>事件 &amp; 描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>newListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数该事件在添加新监听器时被触发。</td>
</tr>
<tr>
<td>2</td>
<td><strong>removeListener</strong> <strong>event</strong> - 字符串，事件名称<strong>listener</strong> - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>实例</strong></p>
<p>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。</p>
<p>创建 main.js 文件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.var events = require(&#x27;events&#x27;);</span><br><span class="line">2. var eventEmitter = new events.EventEmitter();</span><br><span class="line">3. // 监听器 #1</span><br><span class="line">4. var listener1 = function listener1() &#123;</span><br><span class="line">5.   console.log(&#x27;监听器 listener1 执行。&#x27;);</span><br><span class="line">6. &#125;</span><br><span class="line">7. // 监听器 #2</span><br><span class="line">8. var listener2 = function listener2() &#123;</span><br><span class="line">9.  console.log(&#x27;监听器 listener2 执行。&#x27;);</span><br><span class="line">10. &#125;</span><br><span class="line">11. // 绑定 connection 事件，处理函数为 listener1</span><br><span class="line">12. eventEmitter.addListener(&#x27;connection&#x27;, listener1);</span><br><span class="line">13. // 绑定 connection 事件，处理函数为 listener2</span><br><span class="line">14. eventEmitter.on(&#x27;connection&#x27;, listener2);</span><br><span class="line">15. var eventListeners = eventEmitter.listenerCount(&#x27;connection&#x27;);</span><br><span class="line">16. console.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);</span><br><span class="line">17. // 处理 connection 事件</span><br><span class="line">18. eventEmitter.emit(&#x27;connection&#x27;);</span><br><span class="line">19. // 移除监绑定的 listener1 函数</span><br><span class="line">20. eventEmitter.removeListener(&#x27;connection&#x27;, listener1);</span><br><span class="line">21. console.log(&quot;listener1 不再受监听。&quot;);</span><br><span class="line">22. // 触发连接事件</span><br><span class="line">23. eventEmitter.emit(&#x27;connection&#x27;);</span><br><span class="line">24. eventListeners = eventEmitter.listenerCount(&#x27;connection&#x27;);</span><br><span class="line">25. console.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);</span><br><span class="line">26. console.log(&quot;程序执行完毕。&quot;);</span><br></pre></td></tr></table></figure>
<p>以上代码，执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. $ node main.js</span><br><span class="line">2. 2 个监听器监听连接事件。</span><br><span class="line">3. 监听器 listener1 执行。</span><br><span class="line">4. 监听器 listener2 执行。</span><br><span class="line">5. listener1 不再受监听。</span><br><span class="line">6. 监听器 listener2 执行。</span><br><span class="line">7. 1 个监听器监听连接事件。</span><br><span class="line">8. 程序执行完毕。</span><br></pre></td></tr></table></figure>
<p><strong>error</strong> <strong>事件</strong></p>
<p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p>
<p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p>
<p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. var events = require(&#x27;events&#x27;);</span><br><span class="line">2. var emitter = new events.EventEmitter();</span><br><span class="line">3. emitter.emit(&#x27;error&#x27;);</span><br></pre></td></tr></table></figure>
<p>运行时会显示以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. node.js:201</span><br><span class="line">2. throw e; // process.nextTick error, or &#x27;error&#x27; event on first tick</span><br><span class="line">3. ^</span><br><span class="line">4. Error: Uncaught, unspecified &#x27;error&#x27; event.</span><br><span class="line">5. at EventEmitter.emit (events.js:50:15)</span><br><span class="line">6. at Object. (/home/byvoid/error.js:5:9)</span><br><span class="line">7. at Module._compile (module.js:441:26)</span><br><span class="line">8. at Object..js (module.js:459:10)</span><br><span class="line">9. at Module.load (module.js:348:31)</span><br><span class="line">10. at Function._load (module.js:308:12)</span><br><span class="line">11. at Array.0 (module.js:479:10)</span><br><span class="line">12. at EventEmitter._tickCallback (node.js:192:40)</span><br></pre></td></tr></table></figure>
<p><strong>继承 EventEmitter</strong></p>
<p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>
<p>为什么要这样做呢？原因有两点：</p>
<p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p>
<p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>
<p><strong>Node.js Buffer</strong></p>
<p><strong>Node.js Buffer**</strong>（缓冲区）**</p>
<p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p>
<p>但在处理像 TCP 流或文件流时，必须使用到二进制数据。因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p>
<p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理 I/O 操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p>
<p>在 v6.0 之前创建 Buffer 对象直接使用 new Buffer() 构造函数来创建对象实例，但是 Buffer 对内存的权限操作相比很大，可以直接捕获一些敏感信息，所以在 v6.0 以后，官方文档里面建议使用 Buffer.from() 接口去创建 Buffer 对象。</p>
<p><strong>Buffer</strong> <strong>与字符编码</strong></p>
<p>Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. const buf = Buffer.from(&#x27;axihe&#x27;, &#x27;ascii&#x27;);</span><br><span class="line">2. // 输出 72756e6f6f62</span><br><span class="line">3. console.log(buf.toString(&#x27;hex&#x27;));</span><br><span class="line">4. // 输出 cnVub29i</span><br><span class="line">5. console.log(buf.toString(&#x27;base64&#x27;));</span><br></pre></td></tr></table></figure>
<p><strong>Node.js</strong> <strong>目前支持的字符编码包括：</strong></p>
<ul>
<li><strong>ascii</strong> - 仅支持 7 位     ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</li>
<li><strong>utf8</strong> - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</li>
<li><strong>utf16le</strong> - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</li>
<li><strong>ucs2</strong> - <strong>utf16le</strong> 的别名。</li>
<li><strong>base64</strong> - Base64 编码。</li>
<li><strong>latin1</strong> - 一种把 <strong>Buffer</strong> 编码成一字节编码的字符串的方式。</li>
<li><strong>binary</strong> - <strong>latin1</strong> 的别名。</li>
<li><strong>hex</strong> - 将每个字节编码为两个十六进制字符。</li>
</ul>
<p><strong>创建 Buffer 类</strong></p>
<p>Buffer 提供了以下 API 来创建 Buffer 类：</p>
<ul>
<li><strong>Buffer.alloc(size[,     fill[, encoding]])**</strong>：** 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</li>
<li><strong>Buffer.allocUnsafe(size)**</strong>：** 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</li>
<li><strong>Buffer.allocUnsafeSlow(size)</strong></li>
<li><strong>Buffer.from(array)**</strong>：** 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</li>
<li><strong>Buffer.from(arrayBuffer[,     byteOffset[, length]])**</strong>：** 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</li>
<li><strong>Buffer.from(buffer)**</strong>：** 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</li>
<li><strong>Buffer.from(string[,     encoding])**</strong>：** 返回一个被 string 的值初始化的新的 Buffer 实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> i.   // 创建一个长度为 10、且用 0 填充的 Buffer。</span><br><span class="line">ii.   const buf1 = Buffer.alloc(10);</span><br><span class="line">iii.   // 创建一个长度为 10、且用 0x1 填充的 Buffer。</span><br><span class="line">iv.   const buf2 = Buffer.alloc(10, 1);</span><br><span class="line">v.   // 创建一个长度为 10、且未初始化的 Buffer。</span><br><span class="line">vi.   // 这个方法比调用 Buffer.alloc() 更快，</span><br><span class="line">vii.   // 但返回的 Buffer 实例可能包含旧数据，</span><br><span class="line">viii.   // 因此需要使用 fill() 或 write() 重写。</span><br><span class="line">ix.   const buf3 = Buffer.allocUnsafe(10);</span><br><span class="line">x.   // 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。</span><br><span class="line">xi.   const buf4 = Buffer.from([1, 2, 3]);</span><br><span class="line">xii.   // 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。</span><br><span class="line">xiii.   const buf5 = Buffer.from(&#x27;tést&#x27;);</span><br><span class="line">xiv.   // 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。</span><br><span class="line">xv.   const buf6 = Buffer.from(&#x27;tést&#x27;, &#x27;latin1&#x27;);</span><br></pre></td></tr></table></figure>
<p><strong>写入缓冲区</strong></p>
<p><strong>语法</strong></p>
<p>写入 Node 缓冲区的语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. buf.write(string[, offset[, length]][, encoding])</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<p>参数描述如下：</p>
<ul>
<li><strong>string</strong> - 写入缓冲区的字符串。</li>
<li><strong>offset</strong> - 缓冲区开始写入的索引值，默认为 0 。</li>
<li><strong>length</strong> - 写入的字节数，默认为 buffer.length</li>
<li><strong>encoding</strong> - 使用的编码。默认为 ‘utf8’ 。</li>
</ul>
<p>根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。</p>
<p><strong>返回值</strong></p>
<p>返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. buf = Buffer.alloc(256);</span><br><span class="line">2. len = buf.write(&quot;www.axihe.com&quot;);</span><br><span class="line">3. console.log(&quot;写入字节数 : &quot;+ len);</span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. $node main.js</span><br><span class="line">2. 写入字节数 : 14</span><br></pre></td></tr></table></figure>
<p><strong>从缓冲区读取数据</strong></p>
<p><strong>语法</strong></p>
<p>读取 Node 缓冲区数据的语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. buf.toString([encoding[, start[, end]]])</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<p>参数描述如下：</p>
<ul>
<li><strong>encoding</strong> - 使用的编码。默认为 ‘utf8’ 。</li>
<li><strong>start</strong> - 指定开始读取的索引位置，默认为 0。</li>
<li><strong>end</strong> - 结束位置，默认为缓冲区的末尾。</li>
</ul>
<p><strong>返回值</strong></p>
<p>解码缓冲区数据并使用指定的编码返回字符串。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. buf = Buffer.alloc(26);</span><br><span class="line">2. for (var i = 0 ; i &lt; 26 ; i++) &#123;</span><br><span class="line">3.  buf[i] = i + 97;</span><br><span class="line">4. &#125;</span><br><span class="line">5. console.log( buf.toString(&#x27;ascii&#x27;));    // 输出: abcdefghijklmnopqrstuvwxyz</span><br><span class="line">6. console.log( buf.toString(&#x27;ascii&#x27;,0,5));  // 输出: abcde</span><br><span class="line">7. console.log( buf.toString(&#x27;utf8&#x27;,0,5));  // 输出: abcde</span><br><span class="line">8. console.log( buf.toString(undefined,0,5)); // 使用 &#x27;utf8&#x27; 编码, 并输出: abcde</span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. $ node main.js</span><br><span class="line">2. abcdefghijklmnopqrstuvwxyz</span><br><span class="line">3. abcde</span><br><span class="line">4. abcde</span><br><span class="line">5. abcde</span><br></pre></td></tr></table></figure>
<p><strong>将 Buffer 转换为 JSON 对象</strong></p>
<p><strong>语法</strong></p>
<p>将 Node Buffer 转换为 JSON 对象的函数语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. buf.toJSON()</span><br></pre></td></tr></table></figure>
<p>当字符串化一个 Buffer 实例时，JSON.stringify()会隐式地调用该 toJSON()。</p>
<p><strong>返回值</strong></p>
<p>返回 JSON 对象。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);</span><br><span class="line">2. const json = JSON.stringify(buf);</span><br><span class="line">3. // 输出: &#123;&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]&#125;</span><br><span class="line">4. console.log(json);</span><br><span class="line">5. const copy = JSON.parse(json, (key, value) =&gt; &#123;</span><br><span class="line">6.return value &amp;&amp; value.type === &#x27;Buffer&#x27; ?</span><br><span class="line">7. Buffer.from(value.data) :</span><br><span class="line">8.   value;</span><br><span class="line">9. &#125;);</span><br><span class="line">10. // 输出:</span><br><span class="line">11. console.log(copy);</span><br><span class="line">执行以上代码，输出结果为：</span><br><span class="line">1. &#123;&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]&#125;</span><br></pre></td></tr></table></figure>
<p><strong>缓冲区合并</strong></p>
<p><strong>语法</strong></p>
<p>Node 缓冲区合并的语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. Buffer.concat(list[, totalLength])</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<p>参数描述如下：</p>
<ul>
<li><strong>list</strong> - 用于合并的 Buffer 对象数组列表。</li>
<li><strong>totalLength</strong> - 指定合并后 Buffer 对象的总长度。</li>
</ul>
<p><strong>返回值</strong></p>
<p>返回一个多个成员合并的新 Buffer 对象。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. var buffer1 = Buffer.from((&#x27;node&#x27;));</span><br><span class="line">2. var buffer2 = Buffer.from((&#x27;www.codecheng.com&#x27;));</span><br><span class="line">3. var buffer3 = Buffer.concat([buffer1,buffer2]);</span><br><span class="line">4. console.log(&quot;buffer3 内容: &quot; + buffer3.toString());</span><br><span class="line">执行以上代码，输出结果为：</span><br><span class="line">1. buffer3 内容: nodewww.codecheng.com</span><br></pre></td></tr></table></figure>
<p><strong>缓冲区比较</strong></p>
<p><strong>语法</strong></p>
<p>Node Buffer 比较的函数语法如下所示，该方法在 Node.js v0.12.2 版本引入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. buf.compare(otherBuffer);</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<p>参数描述如下：</p>
<ul>
<li><strong>otherBuffer</strong> - 与 <strong>buf</strong> 对象比较的另外一个 Buffer 对象。</li>
</ul>
<p><strong>返回值</strong></p>
<p>返回一个数字，表示 <strong>buf</strong> 在 <strong>otherBuffer</strong> 之前，之后或相同。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. var buffer1 = Buffer.from(&#x27;ABC&#x27;);</span><br><span class="line">2. var buffer2 = Buffer.from(&#x27;ABCD&#x27;);</span><br><span class="line">3. var result = buffer1.compare(buffer2);</span><br><span class="line">4. if(result &lt; 0) &#123;</span><br><span class="line">5.   console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之前&quot;);</span><br><span class="line">6. &#125;else if(result == 0)&#123;</span><br><span class="line">7.   console.log(buffer1 + &quot; 与 &quot; + buffer2 + &quot;相同&quot;);</span><br><span class="line">8. &#125;else &#123;</span><br><span class="line">9.   console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之后&quot;);</span><br><span class="line">10. &#125;</span><br><span class="line">执行以上代码，输出结果为：</span><br><span class="line">1. ABC在ABCD之前</span><br></pre></td></tr></table></figure>
<p><strong>拷贝缓冲区</strong></p>
<p><strong>语法</strong></p>
<p>Node 缓冲区拷贝语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<p>参数描述如下：</p>
<ul>
<li><strong>targetBuffer</strong> - 要拷贝的 Buffer 对象。</li>
<li><strong>targetStart</strong> - 数字，可选，默认：0</li>
<li><strong>sourceStart</strong> - 数字，可选，默认：0</li>
<li><strong>sourceEnd</strong> - 数字，可选，默认：buffer.length</li>
</ul>
<p><strong>返回值</strong></p>
<p>没有返回值。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. var buf1 = Buffer.from(&#x27;abcdefghijkl&#x27;);</span><br><span class="line">2. var buf2 = Buffer.from(&#x27;axihe&#x27;);</span><br><span class="line">3. //将 buf2 插入到 buf1 指定位置上</span><br><span class="line">4. buf2.copy(buf1, 2);</span><br><span class="line">5. console.log(buf1.toString());</span><br><span class="line">执行以上代码，输出结果为：</span><br><span class="line">1. abaxiheijkl</span><br></pre></td></tr></table></figure>
<p><strong>缓冲区裁剪</strong></p>
<p>Node 缓冲区裁剪语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. buf.slice([start[, end]])</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<p>参数描述如下：</p>
<ul>
<li><strong>start</strong> - 数字，可选，默认：0</li>
<li><strong>end</strong> - 数字，可选，默认：buffer.length</li>
</ul>
<p><strong>返回值</strong></p>
<p>返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. var buffer1 = Buffer.from(&#x27;axihe&#x27;);</span><br><span class="line">2. // 剪切缓冲区</span><br><span class="line">3. var buffer2 = buffer1.slice(0,2);</span><br><span class="line">4. console.log(&quot;buffer2 content: &quot; + buffer2.toString());</span><br><span class="line">执行以上代码，输出结果为：</span><br><span class="line">1. buffer2 content: ru</span><br></pre></td></tr></table></figure>
<p><strong>缓冲区长度</strong></p>
<p><strong>语法</strong></p>
<p>Node 缓冲区长度计算语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. buf.length;</span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong></p>
<p>返回 Buffer 对象所占据的内存长度。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. var buffer = Buffer.from(&#x27;www.axihe.com&#x27;);</span><br><span class="line">2. // 缓冲区长度</span><br><span class="line">3. console.log(&quot;buffer length: &quot; + buffer.length);</span><br><span class="line">执行以上代码，输出结果为：</span><br><span class="line">1. buffer length: 14</span><br></pre></td></tr></table></figure>
<p><strong>方法参考手册</strong></p>
<p>以下列出了 Node.js Buffer 模块常用的方法（注意有些方法在旧版本是没有的）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法 &amp; 描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>new  Buffer(size)</strong> 分配一个新的 size 大小单位为8位字节的 buffer。 注意, size 必须小于 kMaxLength，否则，将会抛出异常 RangeError。废弃的: 使用 Buffer.alloc() 代替（或 Buffer.allocUnsafe()）。</td>
</tr>
<tr>
<td>2</td>
<td><strong>new  Buffer(buffer)</strong> 拷贝参数 buffer 的数据到 Buffer 实例。废弃的: 使用 Buffer.from(buffer) 代替。</td>
</tr>
<tr>
<td>3</td>
<td><strong>new  Buffer(str[, encoding])</strong> 分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 ‘utf8’。 废弃的: 使用  Buffer.from(string[, encoding]) 代替。</td>
</tr>
<tr>
<td>4</td>
<td><strong>buf.length</strong> 返回这个 buffer 的  bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。</td>
</tr>
<tr>
<td>5</td>
<td><strong>buf.write(string[,  offset[, length]][, encoding])</strong> 根据参数 offset 偏移量和指定的 encoding 编码方式，将参数 string 数据写入buffer。 offset 偏移量默认值是 0, encoding 编码方式默认是 utf8。 length 长度是将要写入的字符串的 bytes 大小。 返回 number 类型，表示写入了多少 8 位字节流。如果 buffer 没有足够的空间来放整个 string，它将只会只写入部分字符串。 length 默认是 buffer.length - offset。  这个方法不会出现写入部分字符。</td>
</tr>
<tr>
<td>6</td>
<td><strong>buf.writeUIntLE(value,  offset, byteLength[, noAssert])</strong> 将 value 写入到  buffer 里， 它由 offset 和  byteLength 决定，最高支持 48 位无符号整数，小端对齐，例如： const buf = Buffer.allocUnsafe(6);  buf.writeUIntLE(0x1234567890ab, 0, 6); // 输出：<Buffer ab 90 78 56  34 12>console.log(buf);noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td>
</tr>
<tr>
<td>7</td>
<td><strong>buf.writeUIntBE(value,  offset, byteLength[, noAssert])</strong> 将 value 写入到  buffer 里， 它由 offset 和  byteLength 决定，最高支持 48 位无符号整数，大端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。const buf = Buffer.allocUnsafe(6);  buf.writeUIntBE(0x1234567890ab, 0, 6); // 输出：<Buffer 12 34 56 78  90 ab>console.log(buf);</td>
</tr>
<tr>
<td>8</td>
<td><strong>buf.writeIntLE(value,  offset, byteLength[, noAssert])</strong> 将value 写入到  buffer 里， 它由offset 和  byteLength 决定，最高支持48位有符号整数，小端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td>
</tr>
<tr>
<td>9</td>
<td><strong>buf.writeIntBE(value,  offset, byteLength[, noAssert])</strong> 将value 写入到  buffer 里， 它由offset 和 byteLength  决定，最高支持48位有符号整数，大端对齐。noAssert  值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</td>
</tr>
<tr>
<td>10</td>
<td><strong>buf.readUIntLE(offset,  byteLength[, noAssert])</strong> 支持读取 48 位以下的无符号数字，小端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td>
</tr>
<tr>
<td>11</td>
<td><strong>buf.readUIntBE(offset,  byteLength[, noAssert])</strong> 支持读取 48 位以下的无符号数字，大端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td>
</tr>
<tr>
<td>12</td>
<td><strong>buf.readIntLE(offset,  byteLength[, noAssert])</strong> 支持读取 48 位以下的有符号数字，小端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td>
</tr>
<tr>
<td>13</td>
<td><strong>buf.readIntBE(offset,  byteLength[, noAssert])</strong> 支持读取 48 位以下的有符号数字，大端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</td>
</tr>
<tr>
<td>14</td>
<td><strong>buf.toString([encoding[,  start[, end]]])</strong> 根据 encoding 参数（默认是 ‘utf8’）返回一个解码过的 string 类型。还会根据传入的参数 start (默认是 0) 和 end (默认是  buffer.length)作为取值范围。</td>
</tr>
<tr>
<td>15</td>
<td><strong>buf.toJSON()</strong> 将 Buffer 实例转换为  JSON 对象。</td>
</tr>
<tr>
<td>16</td>
<td><strong>buf[index]</strong> 获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。</td>
</tr>
<tr>
<td>17</td>
<td><strong>buf.equals(otherBuffer)</strong> 比较两个缓冲区是否相等，如果是返回 true，否则返回 false。</td>
</tr>
<tr>
<td>18</td>
<td><strong>buf.compare(otherBuffer)</strong> 比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。</td>
</tr>
<tr>
<td>19</td>
<td><strong>buf.copy(targetBuffer[,  targetStart[, sourceStart[, sourceEnd]]])</strong> buffer 拷贝，源和目标可以相同。 targetStart 目标开始偏移和 sourceStart 源开始偏移默认都是 0。 sourceEnd 源结束位置偏移默认是源的长度 buffer.length 。</td>
</tr>
<tr>
<td>20</td>
<td><strong>buf.slice([start[,  end]])</strong> 剪切 Buffer 对象，根据 start(默认是 0 ) 和 end (默认是  buffer.length ) 偏移和裁剪了索引。 负的索引是从 buffer 尾部开始计算的。</td>
</tr>
<tr>
<td>21</td>
<td><strong>buf.readUInt8(offset[,  noAssert])</strong> 根据指定的偏移量，读取一个无符号 8 位整数。若参数  noAssert 为 true 将不会验证 offset 偏移量参数。  如果这样 offset 可能会超出buffer 的末尾。默认是 false。</td>
</tr>
<tr>
<td>22</td>
<td><strong>buf.readUInt16LE(offset[,  noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 字节序格式读取一个无符号 16 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td>
</tr>
<tr>
<td>23</td>
<td><strong>buf.readUInt16BE(offset[,  noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 字节序格式读取一个无符号 16 位整数，大端对齐。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td>
</tr>
<tr>
<td>24</td>
<td><strong>buf.readUInt32LE(offset[,  noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个无符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td>
</tr>
<tr>
<td>25</td>
<td><strong>buf.readUInt32BE(offset[,  noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个无符号 32 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td>
</tr>
<tr>
<td>26</td>
<td><strong>buf.readInt8(offset[,  noAssert])</strong> 根据指定的偏移量，读取一个有符号 8 位整数。 若参数  noAssert 为 true 将不会验证 offset 偏移量参数。  这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td>
</tr>
<tr>
<td>27</td>
<td><strong>buf.readInt16LE(offset[,  noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 格式读取一个 有符号 16 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td>
</tr>
<tr>
<td>28</td>
<td><strong>buf.readInt16BE(offset[,  noAssert])</strong> 根据指定的偏移量，使用特殊的 endian 格式读取一个 有符号 16 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td>
</tr>
<tr>
<td>29</td>
<td><strong>buf.readInt32LE(offset[,  noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td>
</tr>
<tr>
<td>30</td>
<td><strong>buf.readInt32BE(offset[,  noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</td>
</tr>
<tr>
<td>31</td>
<td><strong>buf.readFloatLE(offset[,  noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个  32 位双浮点数，小端对齐。 若参数 noAssert 为  true 将不会验证 offset 偏移量参数。 这意味着  offset 可能会超出 buffer 的末尾。默认是  false。</td>
</tr>
<tr>
<td>32</td>
<td><strong>buf.readFloatBE(offset[,  noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个  32 位双浮点数，大端对齐。 若参数 noAssert 为  true 将不会验证 offset 偏移量参数。 这意味着  offset 可能会超出 buffer 的末尾。默认是  false。</td>
</tr>
<tr>
<td>33</td>
<td><strong>buf.readDoubleLE(offset[,  noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个  64 位双精度数，小端对齐。 若参数 noAssert 为  true 将不会验证 offset 偏移量参数。 这意味着  offset 可能会超出 buffer 的末尾。默认是  false。</td>
</tr>
<tr>
<td>34</td>
<td><strong>buf.readDoubleBE(offset[,  noAssert])</strong> 根据指定的偏移量，使用指定的 endian 字节序格式读取一个  64 位双精度数，大端对齐。 若参数 noAssert 为  true 将不会验证 offset 偏移量参数。 这意味着  offset 可能会超出 buffer 的末尾。默认是  false。</td>
</tr>
<tr>
<td>35</td>
<td><strong>buf.writeUInt8(value,  offset[, noAssert])</strong> 根据传入的 offset 偏移量将 value 写入 buffer。注意：value 必须是一个合法的无符号 8 位整数。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则不要使用。默认是 false。</td>
</tr>
<tr>
<td>36</td>
<td><strong>buf.writeUInt16LE(value,  offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将  value 写入 buffer。注意：value 必须是一个合法的无符号 16 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
</tr>
<tr>
<td>37</td>
<td><strong>buf.writeUInt16BE(value,  offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的无符号 16 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
</tr>
<tr>
<td>38</td>
<td><strong>buf.writeUInt32LE(value,  offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式 (LITTLE-ENDIAN: 小字节序）将 value 写入 buffer。注意：value 必须是一个合法的无符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是  false。</td>
</tr>
<tr>
<td>39</td>
<td><strong>buf.writeUInt32BE(value,  offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式 (Big-Endian: 大字节序）将 value 写入 buffer。注意：value 必须是一个合法的有符号 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是  false。</td>
</tr>
<tr>
<td>40</td>
<td><strong>buf.writeInt8(value,  offset[, noAssert])</strong> offset=”” 偏移量将=”” value=”” 写入=””  buffer=”” 。注意：value=”” 必须是一个合法的=”” signed=”” 8=”” 位整数。=”” 若参数=”” noassert=”” 为=”” true=”” 将不会验证=”” 和=”” 偏移量参数。=””  这意味着=”” 可能过大，或者=”” 可能会超出=”” 的末尾从而造成=”” 被丢弃。=”” 除非你对这个参数非常有把握，否则尽量不要使用。默认是=”” false。</td>
</tr>
<tr>
<td>41</td>
<td><strong>buf.writeInt16LE(value,  offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。</td>
</tr>
<tr>
<td>42</td>
<td><strong>buf.writeInt16BE(value,  offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。</td>
</tr>
<tr>
<td>43</td>
<td><strong>buf.writeInt32LE(value,  offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
</tr>
<tr>
<td>44</td>
<td><strong>buf.writeInt32BE(value,  offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
</tr>
<tr>
<td>45</td>
<td><strong>buf.writeFloatLE(value,  offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
</tr>
<tr>
<td>46</td>
<td><strong>buf.writeFloatBE(value,  offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</td>
</tr>
<tr>
<td>47</td>
<td><strong>buf.writeDoubleLE(value,  offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位 double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是  false。</td>
</tr>
<tr>
<td>48</td>
<td><strong>buf.writeDoubleBE(value,  offset[, noAssert])</strong> 根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位 double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是  false。</td>
</tr>
<tr>
<td>49</td>
<td><strong>buf.fill(value</strong><a target="_blank" rel="noopener" href="https://www.kuangstudy.com/bbs/, end"><strong>,   offset</strong></a><strong>)</strong> 使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是  buffer.length) ，将会填充整个buffer。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Node.js Stream</strong></p>
<p><strong>Node.js Stream(**</strong>流)**</p>
<p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。</p>
<p>Node.js，Stream 有四种流类型：</p>
<ul>
<li><strong>Readable</strong> - 可读操作。</li>
<li><strong>Writable</strong> - 可写操作。</li>
<li><strong>Duplex</strong> - 可读可写操作.</li>
<li><strong>Transform</strong> - 操作被写入数据，然后读出结果。</li>
</ul>
<p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p>
<ul>
<li><strong>data</strong> - 当有数据可读时触发。</li>
<li><strong>end</strong> - 没有更多的数据可读时触发。</li>
<li><strong>error</strong> - 在接收和写入过程中发生错误时触发。</li>
<li><strong>finish</strong> - 所有数据已被写入到底层系统时触发。</li>
</ul>
<p>介绍常用的流操作。</p>
<p><strong>从流中读取数据</strong></p>
<p>创建 input.txt 文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. 我的博客地址：www.mrschen.top</span><br><span class="line">创建 main.js 文件, 代码如下：</span><br><span class="line">1. var fs = require(&quot;fs&quot;);</span><br><span class="line">2. var data = &#x27;&#x27;;</span><br><span class="line">3. // 创建可读流</span><br><span class="line">4. var readerStream = fs.createReadStream(&#x27;input.txt&#x27;);</span><br><span class="line">5. // 设置编码为 utf8。</span><br><span class="line">6. readerStream.setEncoding(&#x27;UTF8&#x27;);</span><br><span class="line">7. // 处理流事件 --&gt; data, end, and error</span><br><span class="line">8. readerStream.on(&#x27;data&#x27;, function(chunk) &#123;</span><br><span class="line">9.  data += chunk;</span><br><span class="line">10. &#125;);</span><br><span class="line">11. readerStream.on(&#x27;end&#x27;,function()&#123;</span><br><span class="line">12.   console.log(data);</span><br><span class="line">13. &#125;);</span><br><span class="line">14. readerStream.on(&#x27;error&#x27;, function(err)&#123;</span><br><span class="line">15.   console.log(err.stack);</span><br><span class="line">16. &#125;);</span><br><span class="line">17. console.log(&quot;程序执行完毕&quot;);</span><br><span class="line">以上代码执行结果如下：</span><br><span class="line">1. 程序执行完毕</span><br><span class="line">2. 我的博客地址：www.mrschen.top</span><br></pre></td></tr></table></figure>
<p><strong>写入流</strong></p>
<p>创建 main.js 文件, 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. var fs = require(&quot;fs&quot;);</span><br><span class="line">2. var data = &#x27;我的博客地址：www.mrschen.top&#x27;;</span><br><span class="line"></span><br><span class="line">\3. // 创建一个可以写入的流，写入到文件 output.txt 中</span><br><span class="line"></span><br><span class="line">\4. var writerStream = fs.createWriteStream(&#x27;output.txt&#x27;);</span><br><span class="line"></span><br><span class="line">\5. // 使用 utf8 编码写入数据</span><br><span class="line"></span><br><span class="line">\6. writerStream.write(data,&#x27;UTF8&#x27;);</span><br><span class="line"></span><br><span class="line">7. // 标记文件末尾</span><br><span class="line">8. writerStream.end();</span><br><span class="line">9. // 处理流事件 --&gt; data, end, and error</span><br><span class="line">10. writerStream.on(&#x27;finish&#x27;, function() &#123;</span><br><span class="line">11. console.log(&quot;写入完成。&quot;);</span><br><span class="line">12. &#125;);</span><br><span class="line">13. writerStream.on(&#x27;error&#x27;, function(err)&#123;</span><br><span class="line">14.   console.log(err.stack);</span><br><span class="line">15. &#125;);</span><br><span class="line">16. console.log(&quot;程序执行完毕&quot;);</span><br><span class="line">以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：</span><br><span class="line">1. $ node main.js 程序执行完毕写入完成。</span><br></pre></td></tr></table></figure>
<p>查看 output.txt 文件的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ cat output.txt 我的博客地址：www.mrschen.top</span><br></pre></td></tr></table></figure>
<p><strong>管道流</strong></p>
<p>管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。</p>
<p><img src="C:\Users\86133\Pictures\node12.jpg" alt="img"></p>
<p>如上面的图片所示，我们把文件比作装水的桶，而水就是文件里的内容，我们用一根管子(pipe)连接两个桶使得水从一个桶流入另一个桶，这样就慢慢的实现了大文件的复制过程。</p>
<p>以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。</p>
<p>设置 input.txt 文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 我的博客地址：www.mrschen.top管道流操作实例</span><br><span class="line">创建 main.js 文件, 代码如下：</span><br><span class="line">1. var fs = require(&quot;fs&quot;);</span><br><span class="line">2. // 创建一个可读流</span><br><span class="line">3. var readerStream = fs.createReadStream(&#x27;input.txt&#x27;);</span><br><span class="line">4. // 创建一个可写流</span><br><span class="line">5. var writerStream = fs.createWriteStream(&#x27;output.txt&#x27;);</span><br><span class="line">6. // 管道读写操作</span><br><span class="line">7. // 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中</span><br><span class="line">8. readerStream.pipe(writerStream);</span><br><span class="line">9. console.log(&quot;程序执行完毕&quot;);</span><br><span class="line">代码执行结果如下：</span><br><span class="line">1. $ node main.js 程序执行完毕</span><br><span class="line">查看 output.txt 文件的内容：</span><br><span class="line">1. $ cat output.txt 我的博客地址：www.mrschen.top管道流操作实例</span><br></pre></td></tr></table></figure>
<p><strong>链式流</strong></p>
<p>链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。</p>
<p>接下来我们就是用管道和链式来压缩和解压文件。</p>
<p>创建 compress.js 文件, 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. var fs = require(&quot;fs&quot;);</span><br><span class="line">2. var zlib = require(&#x27;zlib&#x27;);</span><br><span class="line">3. // 压缩 input.txt 文件为 input.txt.gz</span><br><span class="line">4. fs.createReadStream(&#x27;input.txt&#x27;)</span><br><span class="line">5.  .pipe(zlib.createGzip())</span><br><span class="line">6.  .pipe(fs.createWriteStream(&#x27;input.txt.gz&#x27;));</span><br><span class="line">7.  </span><br><span class="line">8. console.log(&quot;文件压缩完成。&quot;);</span><br><span class="line">代码执行结果如下：</span><br><span class="line">1. $ node compress.js 文件压缩完成。</span><br><span class="line">执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。</span><br><span class="line">接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：</span><br><span class="line">1. var fs = require(&quot;fs&quot;);</span><br><span class="line">2. var zlib = require(&#x27;zlib&#x27;);</span><br><span class="line">3. // 解压 input.txt.gz 文件为 input.txt</span><br><span class="line">4. fs.createReadStream(&#x27;input.txt.gz&#x27;)</span><br><span class="line">5.  .pipe(zlib.createGunzip())</span><br><span class="line">6.  .pipe(fs.createWriteStream(&#x27;input.txt&#x27;));</span><br><span class="line">7.  </span><br><span class="line">8. console.log(&quot;文件解压完成。&quot;);</span><br><span class="line">代码执行结果如下：</span><br><span class="line">\1. $ node decompress.js 文件解压完成。</span><br></pre></td></tr></table></figure>
<p><strong>Node.js</strong> <strong>模块系统</strong></p>
<p><strong>Node.js**</strong>模块系统**</p>
<p>为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。</p>
<p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。</p>
<p><strong>创建模块</strong></p>
<p>在 Node.js 中，创建一个模块非常简单，如下我们创建一个 <strong>main.js</strong> 文件，代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. var hello = require(&#x27;./hello&#x27;);</span><br><span class="line">2. hello.world();</span><br></pre></td></tr></table></figure>
<p>以上实例中，代码 require(‘./hello’) 引入了当前目录下的 hello.js 文件（./ 为当前目录，node.js 默认后缀为 js）。</p>
<p>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。</p>
<p>接下来我们就来创建 hello.js 文件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. exports.world = function() &#123;</span><br><span class="line">2.  console.log(&#x27;Hello World&#x27;);</span><br><span class="line">3. &#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘./hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。</p>
<p>有时候我们只是想把一个对象封装到模块中，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. module.exports = function() &#123;</span><br><span class="line">2.  // ...</span><br><span class="line">例如:</span><br><span class="line">1. //hello.js</span><br><span class="line">2. function Hello() &#123; </span><br><span class="line">3.   var name; </span><br><span class="line">4.   this.setName = function(thyName) &#123; </span><br><span class="line">5.     name = thyName; </span><br><span class="line">6.   &#125;; </span><br><span class="line">7.   this.sayHello = function() &#123; </span><br><span class="line">8.     console.log(&#x27;Hello &#x27; + name); </span><br><span class="line">9.   &#125;; </span><br><span class="line">10. &#125;; </span><br><span class="line">11. module.exports = Hello;</span><br><span class="line">这样就可以直接获得这个对象了：</span><br><span class="line">1. //main.js </span><br><span class="line">2. var Hello = require(&#x27;./hello&#x27;); </span><br><span class="line">3. hello = new Hello(); </span><br><span class="line">4. hello.setName(&#x27;BYVoid&#x27;); </span><br><span class="line">5. hello.sayHello();</span><br></pre></td></tr></table></figure>
<p>模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。</p>
<p><strong>服务端的模块放在哪里</strong></p>
<p>也许你已经注意到，我们已经在代码中使用了模块了。像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. var http = require(&quot;http&quot;);</span><br><span class="line">2. ...</span><br><span class="line">3. http.createServer(...);</span><br></pre></td></tr></table></figure>
<p>Node.js 中自带了一个叫做 <strong>http</strong> 的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。</p>
<p>这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。</p>
<p>Node.js 的 require 方法中的文件查找策略如下：</p>
<p>由于 Node.js 中存在 4 类模块（原生模块和3种文件模块），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示：</p>
<p><img src="C:\Users\86133\Pictures\node13.jpg" alt="img"></p>
<p><strong>从文件模块缓存中加载</strong></p>
<p>尽管原生模块与文件模块的优先级不同，但是都会优先从文件模块的缓存中加载已经存在的模块。</p>
<p><strong>从原生模块加载</strong></p>
<p>原生模块的优先级仅次于文件模块缓存的优先级。require 方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个 http/http.js/http.node/http.json 文件，require(“http”) 都不会从这些文件中加载，而是从原生模块中加载。</p>
<p>原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。</p>
<p><strong>从文件加载</strong></p>
<p>当文件模块缓存中不存在，而且不是原生模块的时候，Node.js 会解析 require 方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。</p>
<p>require方法接受以下几种参数的传递：</p>
<ul>
<li>http、fs、path等，原生模块。</li>
<li>./mod或../mod，相对路径的文件模块。</li>
<li>/pathtomodule/mod，绝对路径的文件模块。</li>
<li>mod，非原生模块的文件模块。</li>
</ul>
<p>在路径 Y 下执行 require(X) 语句执行顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">\1. 1. 如果 X 是内置模块</span><br><span class="line">2.   a. 返回内置模块</span><br><span class="line">3.   b. 停止执行</span><br><span class="line">4. 2. 如果 X 以 &#x27;/&#x27; 开头</span><br><span class="line">5.   a. 设置 Y 为文件根路径</span><br><span class="line">6. 3. 如果 X 以 &#x27;./&#x27; 或 &#x27;/&#x27; or &#x27;../&#x27; 开头</span><br><span class="line">7.   a. LOAD_AS_FILE(Y + X)</span><br><span class="line">8.   b. LOAD_AS_DIRECTORY(Y + X)</span><br><span class="line">9. 4. LOAD_NODE_MODULES(X, dirname(Y))</span><br><span class="line">10. 5. 抛出异常 &quot;not found&quot;</span><br><span class="line">11. LOAD_AS_FILE(X)</span><br><span class="line">12. 1. 如果 X 是一个文件, 将 X 作为 JavaScript 文本载入并停止执行。</span><br><span class="line">13. 2. 如果 X.js 是一个文件, 将 X.js 作为 JavaScript 文本载入并停止执行。</span><br><span class="line">14. 3. 如果 X.json 是一个文件, 解析 X.json 为 JavaScript 对象并停止执行。</span><br><span class="line">15. 4. 如果 X.node 是一个文件, 将 X.node 作为二进制插件载入并停止执行。</span><br><span class="line">16. LOAD_INDEX(X)</span><br><span class="line">17. 1. 如果 X/index.js 是一个文件, 将 X/index.js 作为 JavaScript 文本载入并停止执行。</span><br><span class="line">18. 2. 如果 X/index.json 是一个文件, 解析 X/index.json 为 JavaScript 对象并停止执行。</span><br><span class="line">19. 3. 如果 X/index.node 是一个文件, 将 X/index.node 作为二进制插件载入并停止执行。</span><br><span class="line">20. LOAD_AS_DIRECTORY(X)</span><br><span class="line">21. 1. 如果 X/package.json 是一个文件,</span><br><span class="line">22.   a. 解析 X/package.json, 并查找 &quot;main&quot; 字段。</span><br><span class="line">23.   b. let M = X + (json main 字段)</span><br><span class="line">24.   c. LOAD_AS_FILE(M)</span><br><span class="line">25.   d. LOAD_INDEX(M)</span><br><span class="line">26. 2. LOAD_INDEX(X)</span><br><span class="line">27. LOAD_NODE_MODULES(X, START)</span><br><span class="line">28. 1. let DIRS=NODE_MODULES_PATHS(START)</span><br><span class="line">29. 2. for each DIR in DIRS:</span><br><span class="line">30.   a. LOAD_AS_FILE(DIR/X)</span><br><span class="line">31.   b. LOAD_AS_DIRECTORY(DIR/X)</span><br><span class="line">32. NODE_MODULES_PATHS(START)</span><br><span class="line">33. 1. let PARTS = path split(START)</span><br><span class="line">34. 2. let I = count of PARTS - 1</span><br><span class="line">35. 3. let DIRS = []</span><br><span class="line">36. 4. while I &gt;= 0,</span><br><span class="line">37.   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE</span><br><span class="line">38.   b. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)</span><br><span class="line">39.   c. DIRS = DIRS + DIR</span><br><span class="line">40.   d. let I = I - 1</span><br><span class="line">41. 5. return DIRS</span><br></pre></td></tr></table></figure>
<p><strong>exports</strong> <strong>和 module.exports 的使用</strong></p>
<p>如果要对外暴露属性或方法，就用 <strong>exports</strong> 就行，要暴露对象(类似class，包含了很多属性和方法)，就用 <strong>module.exports</strong>。</p>
<p><strong>Node.js</strong> <strong>函数</strong></p>
<p><strong>Node.js</strong> <strong>函数</strong></p>
<p>在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。</p>
<p>Node.js中函数的使用与Javascript类似，举例来说，你可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. function say(word) &#123;</span><br><span class="line">2.  console.log(word);</span><br><span class="line">3. &#125;</span><br><span class="line">4. function execute(someFunction, value) &#123;</span><br><span class="line">5.  someFunction(value);</span><br><span class="line">6. &#125;</span><br><span class="line">7. execute(say, &quot;Hello&quot;);</span><br></pre></td></tr></table></figure>
<p>以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！</p>
<p>这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。</p>
<p>当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。</p>
<p><strong>匿名函数</strong></p>
<p>我们可以把一个函数作为变量传递。但是我们不一定要绕这个”先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. function execute(someFunction, value) &#123;</span><br><span class="line">2.  someFunction(value);</span><br><span class="line">3. &#125;</span><br><span class="line">4. execute(function(word)&#123; console.log(word) &#125;, &quot;Hello&quot;);</span><br></pre></td></tr></table></figure>
<p>我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。</p>
<p>用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。</p>
<p><strong>函数传递是如何让HTTP服务器工作的</strong></p>
<p>带着这些知识，我们再来看看我们简约而不简单的HTTP服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. var http = require(&quot;http&quot;);</span><br><span class="line">2. http.createServer(function(request, response) &#123;</span><br><span class="line">3.  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">4.  response.write(&quot;Hello World&quot;);</span><br><span class="line">5.  response.end();</span><br><span class="line">6. &#125;).listen(8888);</span><br></pre></td></tr></table></figure>
<p>现在它看上去应该清晰了很多：我们向 createServer 函数传递了一个匿名函数。</p>
<p>用这样的代码也可以达到同样的目的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. var http = require(&quot;http&quot;);</span><br><span class="line">2. function onRequest(request, response) &#123;</span><br><span class="line">3.  response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">4.  response.write(&quot;Hello World&quot;);</span><br><span class="line">5.  response.end();</span><br><span class="line">6. &#125;</span><br><span class="line">7. http.createServer(onRequest).listen(8888);</span><br></pre></td></tr></table></figure>
<p><strong>Node.js</strong> <strong>路由</strong></p>
<p><strong>Node.js</strong> <strong>路由</strong></p>
<p>我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。</p>
<p>因此，我们需要查看 HTTP 请求，从中提取出请求的 URL 以及 GET/POST 参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的 HTTP 服务器的功能。</p>
<p>我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.    url.parse(string).query</span><br><span class="line">2.                       |</span><br><span class="line">3.       url.parse(string).pathname   |</span><br><span class="line">4.             |          |</span><br><span class="line">5.             |          |</span><br><span class="line">6.            ------ -------------------</span><br><span class="line">7. http://localhost:8888/start?foo=bar&amp;hello=world</span><br><span class="line">8.                 ---    -----</span><br><span class="line">9.                  |     |</span><br><span class="line">10.                  |     |</span><br><span class="line">11.        querystring.parse(queryString)[&quot;foo&quot;]  |</span><br><span class="line">12.                       |</span><br><span class="line">13.              querystring.parse(queryString)[&quot;hello&quot;]</span><br></pre></td></tr></table></figure>
<p>当然我们也可以用 querystring 模块来解析 POST 请求体中的参数，稍后会有演示。</p>
<p>现在我们来给 onRequest() 函数加上一些逻辑，用来找出浏览器请求的 URL 路径：</p>
<p><strong>server.js</strong> <strong>文件代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. var http = require(&quot;http&quot;);</span><br><span class="line">2. var url = require(&quot;url&quot;);</span><br><span class="line">3. function start() &#123;</span><br><span class="line">4.  function onRequest(request, response) &#123;</span><br><span class="line">5.   var pathname = url.parse(request.url).pathname;</span><br><span class="line">6.   console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);</span><br><span class="line">7.   response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">8.   response.write(&quot;Hello World&quot;);</span><br><span class="line">9.   response.end();</span><br><span class="line">10.  &#125;</span><br><span class="line">11.  http.createServer(onRequest).listen(8888);</span><br><span class="line">12.  console.log(&quot;Server has started.&quot;);</span><br><span class="line">13. &#125;</span><br><span class="line">14. exports.start = start;</span><br></pre></td></tr></table></figure>
<p>好了，我们的应用现在可以通过请求的 URL 路径来区别不同请求了 – 这使我们得以使用路由（还未完成）来将请求以 URL 路径为基准映射到处理程序上。</p>
<p>在我们所要构建的应用中，这意味着来自 /start 和 /upload 的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。</p>
<p>现在我们可以来编写路由了，建立一个名为 <strong>router.js</strong> 的文件，添加以下内容：</p>
<p><strong>router.js</strong> <strong>文件代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. function route(pathname) &#123;</span><br><span class="line">2.  console.log(&quot;About to route a request for &quot; + pathname);</span><br><span class="line">3. &#125;</span><br><span class="line">4. exports.route = route;</span><br></pre></td></tr></table></figure>
<p>如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。</p>
<p>我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块。</p>
<p>首先，我们来扩展一下服务器的 start() 函数，以便将路由函数作为参数传递过去，<strong>server.js</strong> 文件代码如下</p>
<p><strong>server.js</strong> <strong>文件代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. var http = require(&quot;http&quot;);</span><br><span class="line">2. var url = require(&quot;url&quot;);</span><br><span class="line">3. function start(route) &#123;</span><br><span class="line">4.  function onRequest(request, response) &#123;</span><br><span class="line">5.   var pathname = url.parse(request.url).pathname;</span><br><span class="line">6.   console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);</span><br><span class="line">7.   route(pathname);</span><br><span class="line">8.   response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">9.   response.write(&quot;Hello World&quot;);</span><br><span class="line">10.   response.end();</span><br><span class="line">11.  &#125;</span><br><span class="line">12.  http.createServer(onRequest).listen(8888);</span><br><span class="line">13.  console.log(&quot;Server has started.&quot;);</span><br><span class="line">14. &#125;</span><br><span class="line">15. exports.start = start;</span><br></pre></td></tr></table></figure>
<p>同时，我们会相应扩展 index.js，使得路由函数可以被注入到服务器中：</p>
<p><strong>index.js</strong> <strong>文件代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. var server = require(&quot;./server&quot;);</span><br><span class="line">2. var router = require(&quot;./router&quot;);</span><br><span class="line">3. server.start(router.route);</span><br></pre></td></tr></table></figure>
<p>在这里，我们传递的函数依旧什么也没做。</p>
<p>如果现在启动应用（node index.js，始终记得这个命令行），随后请求一个 URL，你将会看到应用输出相应的信息，这表明我们的 HTTP 服务器已经在使用路由模块了，并会将请求的路径传递给路由：</p>
<p>\1. $ node index.jsServer has started.</p>
<p>以上输出已经去掉了比较烦人的 /favicon.ico 请求相关的部分。</p>
<p>浏览器访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:8888/，输出结果如下：">http://127.0.0.1:8888/，输出结果如下：</a></p>
<p><img src="C:\Users\86133\Pictures\node14.jpg" alt="img"></p>
<p><strong>Node.js</strong> <strong>常用工具</strong></p>
<p><strong>Node.js</strong> <strong>常用工具</strong></p>
<p>util 是一个 Node.js 核心模块，提供常用函数的集合，用于弥补核心 JavaScript 的功能 过于精简的不足。</p>
<p><strong>util.inherits</strong></p>
<p>util.inherits(constructor, superConstructor) 是一个实现对象间原型继承的函数。</p>
<p>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有提供对象继承的语言级别特性，而是通过原型复制来实现的。</p>
<p>在这里我们只介绍 util.inherits 的用法，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. var util = require(&#x27;util&#x27;);</span><br><span class="line">2. function Base() &#123;</span><br><span class="line">3.   this.name = &#x27;base&#x27;;</span><br><span class="line">4.   this.base = 1991;</span><br><span class="line">5.   this.sayHello = function() &#123;</span><br><span class="line">6.   console.log(&#x27;Hello &#x27; + this.name);</span><br><span class="line">7.   &#125;;</span><br><span class="line">8. &#125;</span><br><span class="line">9. Base.prototype.showName = function() &#123;</span><br><span class="line">10.   console.log(this.name);</span><br><span class="line">11. &#125;;</span><br><span class="line">12. function Sub() &#123;</span><br><span class="line">13.   this.name = &#x27;sub&#x27;;</span><br><span class="line">14. &#125;</span><br><span class="line">15. util.inherits(Sub, Base);</span><br><span class="line">16. var objBase = new Base();</span><br><span class="line">17. objBase.showName();</span><br><span class="line">18. objBase.sayHello();</span><br><span class="line">19. console.log(objBase);</span><br><span class="line">20. var objSub = new Sub();</span><br><span class="line">21. objSub.showName();</span><br><span class="line">22. //objSub.sayHello();</span><br><span class="line">23. console.log(objSub);</span><br></pre></td></tr></table></figure>
<p>我们定义了一个基础对象 Base 和一个继承自 Base 的 Sub，Base 有三个在构造函数内定义的属性和一个原型中定义的函数，通过 util.inherits 实现继承。运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. base</span><br><span class="line">2. Hello base</span><br><span class="line">3. &#123; name: &#x27;base&#x27;, base: 1991, sayHello: [Function] &#125;</span><br><span class="line">4. sub</span><br><span class="line">5. &#123; name: &#x27;sub&#x27; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>Sub 仅仅继承了 Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。</p>
<p>同时，在原型中定义的属性不会被 console.log 作 为对象的属性输出。如果我们去掉 objSub.sayHello(); 这行的注释，将会看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. node.js:201throw e; // process.nextTick error, or &#x27;error&#x27; event on first tick^TypeError: Object #&lt;Sub&gt; has no method &#x27;sayHello&#x27;at Object.&lt;anonymous&gt; (/home/byvoid/utilinherits.js:29:8)at Module._compile (module.js:441:26)at Object..js (module.js:459:10)at Module.load (module.js:348:31)at Function._load (module.js:308:12)at Array.0 (module.js:479:10)at EventEmitter._tickCallback (node.js:192:40)node.js:201</span><br><span class="line">2. throw e; // process.nextTick error, or &#x27;error&#x27; event on first tick</span><br><span class="line">3. ^</span><br><span class="line">4. TypeError: Object #&lt;Sub&gt; has no method &#x27;sayHello&#x27;</span><br><span class="line">5. at Object.&lt;anonymous&gt; (/home/byvoid/utilinherits.js:29:8)</span><br><span class="line">6. at Module._compile (module.js:441:26)</span><br><span class="line">7. at Object..js (module.js:459:10)</span><br><span class="line">8. at Module.load (module.js:348:31)</span><br><span class="line">9. at Function._load (module.js:308:12)</span><br><span class="line">10. at Array.0 (module.js:479:10)</span><br><span class="line">11. at EventEmitter._tickCallback (node.js:192:40)</span><br></pre></td></tr></table></figure>
<p><strong>util.inspect</strong></p>
<p>util.inspect(object,[showHidden],[depth],[colors]) 是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。</p>
<p>showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。</p>
<p>depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定 depth，默认会递归 2 层，指定为 null 表示将不限递归层数完整遍历对象。 如果 color 值为 true，输出格式将会以 ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。</p>
<p>特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了 toString 方法也不会调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. var util = require(&#x27;util&#x27;);</span><br><span class="line">2. function Person() &#123;</span><br><span class="line">3.   this.name = &#x27;byvoid&#x27;;</span><br><span class="line">4.   this.toString = function() &#123;</span><br><span class="line">5.   return this.name;</span><br><span class="line">6.   &#125;;</span><br><span class="line">7. &#125;</span><br><span class="line">8. var obj = new Person();</span><br><span class="line">9. console.log(util.inspect(obj));</span><br><span class="line">10. console.log(util.inspect(obj, true));</span><br></pre></td></tr></table></figure>
<p>运行结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. Person &#123; name: &#x27;byvoid&#x27;, toString: [Function] &#125;</span><br><span class="line">2. Person &#123;</span><br><span class="line">3.  name: &#x27;byvoid&#x27;,</span><br><span class="line">4.  toString:</span><br><span class="line">5.   &#123; [Function]</span><br><span class="line">6.    [length]: 0,</span><br><span class="line">7.    [name]: &#x27;&#x27;,</span><br><span class="line">8.    [arguments]: null,</span><br><span class="line">9.    [caller]: null,</span><br><span class="line">10.    [prototype]: &#123; [constructor]: [Circular] &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>util.isArray(object)</strong></p>
<p>如果给定的参数 “object” 是一个数组返回 true，否则返回 false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. var util = require(&#x27;util&#x27;);</span><br><span class="line">2. util.isArray([])</span><br><span class="line">3.  // true</span><br><span class="line">4. util.isArray(new Array)</span><br><span class="line">5.  // true</span><br><span class="line">6. util.isArray(&#123;&#125;)</span><br><span class="line">7.  // false</span><br></pre></td></tr></table></figure>
<p><strong>util.isRegExp(object)</strong></p>
<p>如果给定的参数 “object” 是一个正则表达式返回 true，否则返回 false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. var util = require(&#x27;util&#x27;);</span><br><span class="line">2. util.isRegExp(/some regexp/)</span><br><span class="line">3.  // true</span><br><span class="line">4. util.isRegExp(new RegExp(&#x27;another regexp&#x27;))</span><br><span class="line">5.  // true</span><br><span class="line">6. util.isRegExp(&#123;&#125;)</span><br><span class="line">7.  // false</span><br></pre></td></tr></table></figure>
<p><strong>util.isDate(object)</strong></p>
<p>如果给定的参数 “object” 是一个日期返回 true，否则返回 false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. var util = require(&#x27;util&#x27;);</span><br><span class="line">2. util.isDate(new Date())</span><br><span class="line">3.  // true</span><br><span class="line">4. util.isDate(Date())</span><br><span class="line">5.  // false (without &#x27;new&#x27; returns a String)</span><br><span class="line">6. util.isDate(&#123;&#125;)</span><br><span class="line">7.  // false</span><br></pre></td></tr></table></figure>
<p><strong>util.isError(object)</strong></p>
<p>如果给定的参数 “object” 是一个错误对象返回 true，否则返回 false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. var util = require(&#x27;util&#x27;);</span><br><span class="line">2. util.isError(new Error())</span><br><span class="line">3.  // true</span><br><span class="line">4. util.isError(new TypeError())</span><br><span class="line">5.  // true</span><br><span class="line">6. util.isError(&#123; name: &#x27;Error&#x27;, message: &#x27;an error occurred&#x27; &#125;)</span><br><span class="line">7.  // false</span><br></pre></td></tr></table></figure>
<p><strong>Node.js</strong> <strong>工具模块</strong></p>
<p><strong>Node.js</strong> <strong>工具模块</strong></p>
<p>在 Node.js 模块库中有很多好用的模块。接下来我们为大家介绍几种常用模块的使用：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>模块名 &amp; 描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>OS 模块 提供基本的系统操作函数。</td>
</tr>
<tr>
<td>2</td>
<td>Path 模块 提供了处理和转换文件路径的工具。</td>
</tr>
<tr>
<td>3</td>
<td>Net 模块 用于底层的网络通信。提供了服务端和客户端的的操作。</td>
</tr>
<tr>
<td>4</td>
<td>DNS 模块 用于解析域名。</td>
</tr>
<tr>
<td>5</td>
<td>Domain 模块 简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Node.js Web</strong> <strong>模块</strong></p>
<p><strong>什么是 Web 服务器？</strong></p>
<p>Web 服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，Web 服务器的基本功能就是提供 Web 信息浏览服务。它只需支持 HTTP 协议、HTML 文档格式及 URL，与客户端的网络浏览器配合。</p>
<p>大多数 web 服务器都支持服务端的脚本语言（php、python、ruby）等，并通过脚本语言从数据库获取数据，将结果返回给客户端浏览器。</p>
<p>目前最主流的三个 Web 服务器是 Apache、Nginx、IIS。</p>
<p><strong>Web</strong> <strong>应用架构</strong></p>
<p><img src="C:\Users\86133\Pictures\node15.jpg" alt="Web 应用架构"></p>
<ul>
<li><strong>Client</strong> - 客户端，一般指浏览器，浏览器可以通过 HTTP 协议向服务器请求数据。</li>
<li><strong>Server</strong> - 服务端，一般指 Web 服务器，可以接收客户端请求，并向客户端发送响应数据。</li>
<li><strong>Business</strong> - 业务层， 通过 Web 服务器处理应用程序，如与数据库交互，逻辑运算，调用外部程序等。</li>
<li><strong>Data</strong> - 数据层，一般由数据库组成。</li>
</ul>
<p><strong>使用 Node 创建 Web 服务器</strong></p>
<p>Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. var http = require(&#x27;http&#x27;);</span><br></pre></td></tr></table></figure>
<p>以下是演示一个最基本的 HTTP 服务器架构（使用 8080 端口），创建 server.js 文件，代码如下所示：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. var http = require(&#x27;http&#x27;);</span><br><span class="line">2. var fs = require(&#x27;fs&#x27;);</span><br><span class="line">3. var url = require(&#x27;url&#x27;);</span><br><span class="line">4. // 创建服务器</span><br><span class="line">5. http.createServer( function (request, response) &#123;</span><br><span class="line">6.   // 解析请求，包括文件名</span><br><span class="line">7.   var pathname = url.parse(request.url).pathname;</span><br><span class="line">8.   // 输出请求的文件名</span><br><span class="line">9.   console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);</span><br><span class="line">10.   // 从文件系统中读取请求的文件内容</span><br><span class="line">11.   fs.readFile(pathname.substr(1), function (err, data) &#123;</span><br><span class="line">12.    if (err) &#123;</span><br><span class="line">13.      console.log(err);</span><br><span class="line">14.      // HTTP 状态码: 404 : NOT FOUND</span><br><span class="line">15.      // Content Type: text/html</span><br><span class="line">16.      response.writeHead(404, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;);</span><br><span class="line">17.    &#125;else&#123;</span><br><span class="line">18.      // HTTP 状态码: 200 : OK</span><br><span class="line">19.      // Content Type: text/html</span><br><span class="line">20.      response.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;);</span><br><span class="line">21.      // 响应文件内容</span><br><span class="line">22.      response.write(data.toString());</span><br><span class="line">23.    &#125;</span><br><span class="line">24.    // 发送响应数据</span><br><span class="line">25.    response.end();</span><br><span class="line">26.   &#125;);</span><br><span class="line">27. &#125;).listen(8080);</span><br><span class="line">28. // 控制台会输出以下信息</span><br><span class="line">29. console.log(&#x27;Server running at http://127.0.0.1:8080/&#x27;);</span><br></pre></td></tr></table></figure>
<p>接下来我们在该目录下创建一个 index.html 文件，代码如下：</p>
<p><strong>index.html</strong> <strong>文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;!DOCTYPE html&gt;</span><br><span class="line">2. &lt;html&gt;</span><br><span class="line">3. &lt;head&gt;</span><br><span class="line">4. &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">5. &lt;title&gt;node&lt;/title&gt;</span><br><span class="line">6. &lt;/head&gt;</span><br><span class="line">7. &lt;body&gt;</span><br><span class="line">8.   &lt;h1&gt;我的第一个标题&lt;/h1&gt;</span><br><span class="line">9.   &lt;p&gt;我的第一个段落。&lt;/p&gt;</span><br><span class="line">10. &lt;/body&gt;</span><br><span class="line">11. &lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>执行 server.js 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ node server.jsServer running at http://127.0.0.1:8080/</span><br></pre></td></tr></table></figure>
<p>接着我们在浏览器中打开地址：<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/index.html"><strong>http://127.0.0.1:8080/index.html</strong></a>，显示如下图所示：</p>
<p><img src="C:\Users\86133\Pictures\node16.jpg" alt="img"></p>
<p>执行 server.js 的控制台输出信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. Server running at http://127.0.0.1:8080/</span><br><span class="line">2. Request for /index.html received.   # 客户端请求信息</span><br></pre></td></tr></table></figure>
<p><strong>使用 Node 创建 Web 客户端</strong></p>
<p>Node 创建 Web 客户端需要引入 http 模块，创建 client.js 文件，代码如下所示：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. var http = require(&#x27;http&#x27;);</span><br><span class="line">2. // 用于请求的选项</span><br><span class="line">3. var options = &#123;</span><br><span class="line">4.   host: &#x27;localhost&#x27;,</span><br><span class="line">5.   port: &#x27;8080&#x27;,</span><br><span class="line">6.   path: &#x27;/index.html&#x27;</span><br><span class="line">7. &#125;;</span><br><span class="line">8. // 处理响应的回调函数</span><br><span class="line">9. var callback = function(response)&#123;</span><br><span class="line">10.   // 不断更新数据</span><br><span class="line">11.   var body = &#x27;&#x27;;</span><br><span class="line">12.   response.on(&#x27;data&#x27;, function(data) &#123;</span><br><span class="line">13.    body += data;</span><br><span class="line">14.   &#125;);</span><br><span class="line">15.   response.on(&#x27;end&#x27;, function() &#123;</span><br><span class="line">16.    // 数据接收完成</span><br><span class="line">17.    console.log(body);</span><br><span class="line">18.   &#125;);</span><br><span class="line">19. &#125;</span><br><span class="line">20. // 向服务端发送请求</span><br><span class="line">21. var req = http.request(options, callback);</span><br><span class="line">22. req.end();</span><br></pre></td></tr></table></figure>
<p><strong>新开一个终端</strong>，执行 client.js 文件，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. $ node client.js</span><br><span class="line">2. &lt;!DOCTYPE html&gt;</span><br><span class="line">3. &lt;html&gt;</span><br><span class="line">4. &lt;head&gt;</span><br><span class="line">5. &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">6. &lt;title&gt;node&lt;/title&gt;</span><br><span class="line">7. &lt;/head&gt;</span><br><span class="line">8. &lt;body&gt;</span><br><span class="line">9.   &lt;h1&gt;我的第一个标题&lt;/h1&gt;</span><br><span class="line">10.   &lt;p&gt;我的第一个段落。&lt;/p&gt;</span><br><span class="line">11. &lt;/body&gt;</span><br><span class="line">12. &lt;/html&gt;</span><br><span class="line">执行 server.js 的控制台输出信息如下：</span><br><span class="line">1. Server running at http://127.0.0.1:8080/</span><br><span class="line">2. Request for /index.html received.      # 客户端请求信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Node.js RESTful API</strong></p>
<p><strong>什么是 REST？</strong></p>
<p>REST 即表述性状态传递（英文：Representational State Transfer，简称 REST）是 Roy Fielding 博士在 2000 年他的博士论文中提出来的一种软件架构风格。</p>
<p>表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。需要注意的是，REST 是设计风格而不是标准。REST 通常基于使用 HTTP，URI，和 XML（标准通用标记语言下的一个子集）以及 HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。REST 通常使用 JSON 数据格式。</p>
<p><strong>HTTP</strong> <strong>方法</strong></p>
<p>以下为 REST 基本架构的四个方法：</p>
<ul>
<li><strong>GET</strong> - 用于获取数据。</li>
<li><strong>PUT</strong> - 用于更新或添加数据。</li>
<li><strong>DELETE</strong> - 用于删除数据。</li>
<li><strong>POST</strong> - 用于添加数据。</li>
</ul>
<p><strong>RESTful Web Services</strong></p>
<p>Web service 是一个平台独立的，低耦合的，自包含的、基于可编程的 web 的应用程序，可使用开放的 XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。</p>
<p>基于 REST 架构的 Web Services 即是 RESTful。</p>
<p>由于轻量级以及通过 HTTP 直接传输数据的特性，Web 服务的 RESTful 方法已经成为最常见的替代方法。可以使用各种语言（比如 Java 程序、Perl、Ruby、Python、PHP 和 Javascript\【包括 Ajax]）实现客户端。</p>
<p>RESTful Web 服务通常可以通过自动客户端或代表用户的应用程序访问。但是，这种服务的简便性让用户能够与之直接交互，使用它们的 Web 浏览器构建一个 GET URL 并读取返回的内容。</p>
<p><strong>创建 RESTful</strong></p>
<p>首先，创建一个 json 数据资源文件 users.json，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. &#123;</span><br><span class="line">2. &quot;user1&quot; : &#123;</span><br><span class="line">3. &quot;name&quot; : &quot;mahesh&quot;,</span><br><span class="line">4. &quot;password&quot; : &quot;password1&quot;,</span><br><span class="line">5.&quot;profession&quot; : &quot;teacher&quot;,</span><br><span class="line">6. &quot;id&quot;: 1</span><br><span class="line">7.   &#125;,</span><br><span class="line">8.  &quot;user2&quot; : &#123;</span><br><span class="line">9.  &quot;name&quot; : &quot;suresh&quot;,</span><br><span class="line">10. &quot;password&quot; : &quot;password2&quot;,</span><br><span class="line">11. &quot;profession&quot; : &quot;librarian&quot;,</span><br><span class="line">12.  &quot;id&quot;: 2</span><br><span class="line">13.   &#125;,</span><br><span class="line">14.   &quot;user3&quot; : &#123;</span><br><span class="line">15.    &quot;name&quot; : &quot;ramesh&quot;,</span><br><span class="line">16.    &quot;password&quot; : &quot;password3&quot;,</span><br><span class="line">17.    &quot;profession&quot; : &quot;clerk&quot;,</span><br><span class="line">18.    &quot;id&quot;: 3</span><br><span class="line">19.   &#125;</span><br><span class="line">20. &#125;</span><br></pre></td></tr></table></figure>
<p>基于以上数据，我们创建以下 RESTful API：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>URI</strong></th>
<th><strong>HTTP</strong> <strong>方法</strong></th>
<th><strong>发送内容</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>listUsers</td>
<td>GET</td>
<td>空</td>
<td>显示所有用户列表</td>
</tr>
<tr>
<td>2</td>
<td>addUser</td>
<td>POST</td>
<td>JSON 字符串</td>
<td>添加新用户</td>
</tr>
<tr>
<td>3</td>
<td>deleteUser</td>
<td>DELETE</td>
<td>JSON 字符串</td>
<td>删除用户</td>
</tr>
<tr>
<td>4</td>
<td>:id</td>
<td>GET</td>
<td>空</td>
<td>显示用户详细信息</td>
</tr>
</tbody>
</table>
</div>
<p><strong>获取用户列表：</strong></p>
<p>以下代码，我们创建了 RESTful API <strong>listUsers</strong>，用于读取用户的信息列表， server.js 文件代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. var express = require(&#x27;express&#x27;);</span><br><span class="line">2. var app = express();</span><br><span class="line">3. var fs = require(&quot;fs&quot;);</span><br><span class="line">4. app.get(&#x27;/listUsers&#x27;, function (req, res) &#123;</span><br><span class="line">5.  fs.readFile( __dirname + &quot;/&quot; + &quot;users.json&quot;, &#x27;utf8&#x27;, function (err, data) &#123;</span><br><span class="line">6.  console.log( data );</span><br><span class="line">7.  res.end( data );</span><br><span class="line">8.   &#125;);</span><br><span class="line">9. &#125;)</span><br><span class="line">10. var server = app.listen(8081, function () &#123;</span><br><span class="line">11.  var host = server.address().address</span><br><span class="line">12.  var port = server.address().port</span><br><span class="line">13.  console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)</span><br><span class="line">14. &#125;)</span><br></pre></td></tr></table></figure>
<p>接下来执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. $ node server.js</span><br><span class="line">2. 应用实例，访问地址为 http://0.0.0.0:8081</span><br></pre></td></tr></table></figure>
<p>在浏览器中访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:8081/listUsers，结果如下所示：">http://127.0.0.1:8081/listUsers，结果如下所示：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. &#123;</span><br><span class="line">2.   &quot;user1&quot; : </span><br><span class="line">3.    &quot;name&quot; : &quot;mahesh&quot;,</span><br><span class="line">4.    &quot;password&quot; : &quot;password1&quot;,</span><br><span class="line">5.    &quot;profession&quot; : &quot;teacher&quot;,</span><br><span class="line">6.    &quot;id&quot;: 1</span><br><span class="line">7.   &#125;,</span><br><span class="line">8.   &quot;user2&quot; : &#123;</span><br><span class="line">9.    &quot;name&quot; : &quot;suresh&quot;,</span><br><span class="line">10.    &quot;password&quot; : &quot;password2&quot;,</span><br><span class="line">11.    &quot;profession&quot; : &quot;librarian&quot;,</span><br><span class="line">12.    &quot;id&quot;: 2</span><br><span class="line">13.   &#125;,</span><br><span class="line">14.   &quot;user3&quot; : &#123;</span><br><span class="line">15.    &quot;name&quot; : &quot;ramesh&quot;,</span><br><span class="line">16.    &quot;password&quot; : &quot;password3&quot;,</span><br><span class="line">17.    &quot;profession&quot; : &quot;clerk&quot;,</span><br><span class="line">18.    &quot;id&quot;: 3</span><br><span class="line">19.   &#125;</span><br><span class="line">20. &#125;</span><br></pre></td></tr></table></figure>
<p><strong>添加用户</strong></p>
<p>以下代码，我们创建了 RESTful API <strong>addUser</strong>， 用于添加新的用户数据，server.js 文件代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1. var express = require(&#x27;express&#x27;);</span><br><span class="line">2. var app = express();</span><br><span class="line">3. var fs = require(&quot;fs&quot;);</span><br><span class="line">4. //添加的新用户数据</span><br><span class="line">5. var user = &#123;</span><br><span class="line">6.   &quot;user4&quot; : &#123;</span><br><span class="line">7.   &quot;name&quot; : &quot;mohit&quot;,</span><br><span class="line">8.   &quot;password&quot; : &quot;password4&quot;,</span><br><span class="line">9.  &quot;profession&quot; : &quot;teacher&quot;,</span><br><span class="line">10.    &quot;id&quot;: 4</span><br><span class="line">11.   &#125;</span><br><span class="line">12. &#125;</span><br><span class="line">13. app.get(&#x27;/addUser&#x27;, function (req, res) &#123;</span><br><span class="line">14.   // 读取已存在的数据</span><br><span class="line">15.   fs.readFile( __dirname + &quot;/&quot; + &quot;users.json&quot;, &#x27;utf8&#x27;, function (err, data) &#123;</span><br><span class="line">16.     data = JSON.parse( data );</span><br><span class="line">17.     data[&quot;user4&quot;] = user[&quot;user4&quot;];</span><br><span class="line">18.     console.log( data );</span><br><span class="line">19.     res.end( JSON.stringify(data));</span><br><span class="line">20.   &#125;);</span><br><span class="line">21. &#125;)</span><br><span class="line">22. var server = app.listen(8081, function () &#123;</span><br><span class="line">23.  var host = server.address().address</span><br><span class="line">24.  var port = server.address().port</span><br><span class="line">25.  console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)</span><br><span class="line">26. &#125;)</span><br></pre></td></tr></table></figure>
<p>接下来执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ node server.js应用实例，访问地址为 http://0.0.0.0:8081</span><br></pre></td></tr></table></figure>
<p>在浏览器中访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:8081/addUser，结果如下所示：">http://127.0.0.1:8081/addUser，结果如下所示：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. &#123; user1:</span><br><span class="line">2.   &#123; name: &#x27;mahesh&#x27;,</span><br><span class="line">3.    password: &#x27;password1&#x27;,</span><br><span class="line">4.    profession: &#x27;teacher&#x27;,</span><br><span class="line">5.    id: 1 &#125;,</span><br><span class="line">6.  user2:</span><br><span class="line">7.   &#123; name: &#x27;suresh&#x27;,</span><br><span class="line">8.    password: &#x27;password2&#x27;,</span><br><span class="line">9.    profession: &#x27;librarian&#x27;,</span><br><span class="line">10.    id: 2 &#125;,</span><br><span class="line">11.  user3:</span><br><span class="line">12.   &#123; name: &#x27;ramesh&#x27;,</span><br><span class="line">13.    password: &#x27;password3&#x27;,</span><br><span class="line">14.    profession: &#x27;clerk&#x27;,</span><br><span class="line">15.    id: 3 &#125;,</span><br><span class="line">16.  user4:</span><br><span class="line">17.   &#123; name: &#x27;mohit&#x27;,</span><br><span class="line">18.    password: &#x27;password4&#x27;,</span><br><span class="line">19.    profession: &#x27;teacher&#x27;,</span><br><span class="line">20.    id: 4 &#125;</span><br><span class="line">21. &#125;</span><br></pre></td></tr></table></figure>
<p><strong>显示用户详情</strong></p>
<p>以下代码，我们创建了 RESTful API <strong>:id**</strong>（用户 id）**， 用于读取指定用户的详细信息，server.js 文件代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. var express = require(&#x27;express&#x27;);</span><br><span class="line">2. var app = express();</span><br><span class="line">3. var fs = require(&quot;fs&quot;);</span><br><span class="line">4. app.get(&#x27;/:id&#x27;, function (req, res) &#123;</span><br><span class="line">5.   // 首先我们读取已存在的用户</span><br><span class="line">6.   fs.readFile( __dirname + &quot;/&quot; + &quot;users.json&quot;, &#x27;utf8&#x27;, function (err, data) &#123;</span><br><span class="line">7.   data = JSON.parse( data );</span><br><span class="line">8.   var user = data[&quot;user&quot; + req.params.id]9*</span><br><span class="line">9.   console.log( user );</span><br><span class="line">10.   res.end( JSON.stringify(user));</span><br><span class="line">11.   &#125;);</span><br><span class="line">12. &#125;)</span><br><span class="line">13. var server = app.listen(8081, function () &#123;</span><br><span class="line">14.  var host = server.address().address</span><br><span class="line">15.  var port = server.address().port</span><br><span class="line">16.  console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)</span><br><span class="line">17. &#125;)</span><br></pre></td></tr></table></figure>
<p>接下来执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ node server.js应用实例，访问地址为 http://0.0.0.0:8081</span><br></pre></td></tr></table></figure>
<p>在浏览器中访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:8081/2，结果如下所示：">http://127.0.0.1:8081/2，结果如下所示：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. &#123;</span><br><span class="line">2.   &quot;name&quot;:&quot;suresh&quot;,</span><br><span class="line">3.   &quot;password&quot;:&quot;password2&quot;,</span><br><span class="line">4.   &quot;profession&quot;:&quot;librarian&quot;,</span><br><span class="line">5.   &quot;id&quot;:2</span><br><span class="line">6. &#125;</span><br></pre></td></tr></table></figure>
<p><strong>删除用户</strong></p>
<p>以下代码，我们创建了 RESTful API <strong>deleteUser</strong>， 用于删除指定用户的详细信息，以下实例中，用户 id 为 2，server.js 文件代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. var express = require(&#x27;express&#x27;);</span><br><span class="line">2. var app = express();</span><br><span class="line">3. var fs = require(&quot;fs&quot;);</span><br><span class="line">4. var id = 2;</span><br><span class="line">5. app.get(&#x27;/deleteUser&#x27;, function (req, res) &#123;</span><br><span class="line">6.  // First read existing users.</span><br><span class="line">7.   fs.readFile( __dirname + &quot;/&quot; + &quot;users.json&quot;, &#x27;utf8&#x27;, function (err, data) &#123;</span><br><span class="line">8.   data = JSON.parse( data );</span><br><span class="line">9.   delete data[&quot;user&quot; + id];</span><br><span class="line">10.  console.log( data );</span><br><span class="line">11.   res.end( JSON.stringify(data));</span><br><span class="line">12.   &#125;);</span><br><span class="line">13. &#125;)</span><br><span class="line">14. var server = app.listen(8081, function () &#123;</span><br><span class="line">15.  var host = server.address().address</span><br><span class="line">16.  var port = server.address().port</span><br><span class="line">17.  console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)</span><br><span class="line">18. &#125;)</span><br></pre></td></tr></table></figure>
<p>接下来执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ node server.js应用实例，访问地址为 http://0.0.0.0:8081</span><br></pre></td></tr></table></figure>
<p>在浏览器中访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:8081/deleteUser，结果如下所示：">http://127.0.0.1:8081/deleteUser，结果如下所示：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. &#123; user1:</span><br><span class="line">2. &#123; name: &#x27;mahesh&#x27;,</span><br><span class="line">3. password: &#x27;password1&#x27;,</span><br><span class="line">4. profession: &#x27;teacher&#x27;,</span><br><span class="line">5. id: 1 &#125;,</span><br><span class="line">6. user3:</span><br><span class="line">7. &#123; name: &#x27;ramesh&#x27;,</span><br><span class="line">8. password: &#x27;password3&#x27;,</span><br><span class="line">9. profession: &#x27;clerk&#x27;,</span><br><span class="line">10. id: 3 &#125;</span><br><span class="line">11. &#125;</span><br></pre></td></tr></table></figure>
<p><strong>Node.js</strong> <strong>多进程</strong></p>
<p><strong>Node.js</strong> <strong>多进程</strong></p>
<p>我们都知道 Node.js 是以单线程的模式运行的，但它使用的是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。</p>
<p>每个子进程总是带有三个流对象：child.stdin, child.stdout 和 child.stderr。他们可能会共享父进程的 stdio 流，或者也可以是独立的被导流的流对象。</p>
<p>Node 提供了 child_process 模块来创建子进程，方法有：</p>
<ul>
<li><strong>exec</strong> - child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。</li>
<li><strong>spawn</strong> - child_process.spawn 使用指定的命令行参数创建新进程。</li>
<li><strong>fork</strong> - child_process.fork 是 spawn() 的特殊形式，用于在子进程中运行的模块，如 fork(‘./son.js’) 相当于 spawn(‘node’, [’./son.js’])     。与 spawn 方法不同的是，fork 会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。</li>
</ul>
<p><strong>exec()</strong> <strong>方法</strong></p>
<p>child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。</p>
<p>语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. child_process.exec(command[, options], callback)</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<p>参数说明如下：</p>
<p><strong>command**</strong>：** 字符串， 将要运行的命令，参数使用空格隔开</p>
<p><strong>options</strong> <strong>：对象，可以是：</strong></p>
<ul>
<li>cwd ，字符串，子进程的当前工作目录</li>
<li>env，对象 环境变量键值对</li>
<li>encoding ，字符串，字符编码（默认： ‘utf8’）</li>
<li>shell ，字符串，将要执行命令的 Shell（默认：在 UNIX 中为/bin/sh， 在 Windows 中为cmd.exe， Shell 应当能识别 -c开关在 UNIX 中，或 /s /c 在 Windows 中。 在 Windows 中，命令行解析应当能兼容cmd.exe）</li>
<li>timeout，数字，超时时间（默认： 0）</li>
<li>maxBuffer，数字， 在 stdout 或 stderr 中允许存在的最大缓冲（二进制），如果超出那么子进程将会被杀死 （默认：200*1024）</li>
<li>killSignal ，字符串，结束信号（默认：’SIGTERM’）</li>
<li>uid，数字，设置用户进程的 ID</li>
<li>gid，数字，设置进程组的 ID</li>
</ul>
<p><strong>callback</strong> <strong>：</strong>回调函数，包含三个参数 error, stdout 和 stderr。</p>
<p>exec() 方法返回最大的缓冲区，并等待进程结束，一次性返回缓冲区的内容。</p>
<p><strong>实例</strong></p>
<p>让我们创建两个 js 文件 support.js 和 master.js。</p>
<p><strong>support.js</strong> <strong>文件代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. console.log(&quot;进程 &quot; + process.argv[2] + &quot; 执行。&quot; );</span><br></pre></td></tr></table></figure>
<p><strong>master.js</strong> <strong>文件代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. const fs = require(&#x27;fs&#x27;);</span><br><span class="line">2. const child_process = require(&#x27;child_process&#x27;);</span><br><span class="line">3. for(var i=0; i&lt;3; i++) &#123;</span><br><span class="line">4. var workerProcess = child_process.exec(&#x27;node support.js &#x27;+i, function (error, stdout, stderr) &#123;</span><br><span class="line">5. if (error) &#123;</span><br><span class="line">6.console.log(error.stack);</span><br><span class="line">7. console.log(&#x27;Error code: &#x27;+error.code);</span><br><span class="line"></span><br><span class="line">8.console.log(&#x27;Signal received: &#x27;+error.signal);</span><br><span class="line">9.     &#125;</span><br><span class="line">10. console.log(&#x27;stdout: &#x27; + stdout);</span><br><span class="line"></span><br><span class="line">11. console.log(&#x27;stderr: &#x27; + stderr);</span><br><span class="line">12.   &#125;);</span><br><span class="line">13. workerProcess.on(&#x27;exit&#x27;, function (code) &#123;</span><br><span class="line">14. console.log(&#x27;子进程已退出，退出码 &#x27;+code);</span><br><span class="line">15.   &#125;)</span><br><span class="line">16. &#125;</span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. $ node master.js</span><br><span class="line">2. 子进程已退出，退出码 0</span><br><span class="line">3. stdout: 进程 1 执行。</span><br><span class="line">4. stderr:</span><br><span class="line">5. 子进程已退出，退出码 0</span><br><span class="line">6. stdout: 进程 0 执行。</span><br><span class="line">7. stderr:</span><br><span class="line">8. 子进程已退出，退出码 0</span><br><span class="line">9. stdout: 进程 2 执行。</span><br><span class="line">10. stderr:</span><br></pre></td></tr></table></figure>
<p><strong>spawn()</strong> <strong>方法</strong></p>
<p>child_process.spawn 使用指定的命令行参数创建新进程，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. child_process.spawn(command[, args][, options])</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<p>参数说明如下：</p>
<p><strong>command**</strong>：** 将要运行的命令</p>
<p><strong>args**</strong>：** Array 字符串参数数组</p>
<p><strong>options Object</strong></p>
<ul>
<li>cwd String 子进程的当前工作目录</li>
<li>env Object 环境变量键值对</li>
<li>stdio Array|String 子进程的 stdio 配置</li>
<li>detached Boolean 这个子进程将会变成进程组的领导</li>
<li>uid Number 设置用户进程的 ID</li>
<li>gid Number 设置进程组的 ID</li>
</ul>
<p>spawn() 方法返回流 (stdout &amp; stderr)，在进程返回大量数据时使用。进程一旦开始执行时 spawn() 就开始接收响应。</p>
<p><strong>实例</strong></p>
<p>让我们创建两个 js 文件 support.js 和 master.js。</p>
<p><strong>support.js</strong> <strong>文件代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. console.log(&quot;进程 &quot; + process.argv[2] + &quot; 执行。&quot; );</span><br></pre></td></tr></table></figure>
<p><strong>master.js</strong> <strong>文件代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. const fs = require(&#x27;fs&#x27;);</span><br><span class="line">2. const child_process = require(&#x27;child_process&#x27;);</span><br><span class="line">3. for(var i=0; i&lt;3; i++) &#123;</span><br><span class="line">4. var workerProcess = child_process.spawn(&#x27;node&#x27;, [&#x27;support.js&#x27;, i]);</span><br><span class="line">5.workerProcess.stdout.on(&#x27;data&#x27;, function (data) &#123;</span><br><span class="line">6.  console.log(&#x27;stdout: &#x27; + data);</span><br><span class="line">7.   &#125;);</span><br><span class="line">8.   workerProcess.stderr.on(&#x27;data&#x27;, function (data) &#123;</span><br><span class="line">9.    console.log(&#x27;stderr: &#x27; + data);</span><br><span class="line">10.   &#125;);</span><br><span class="line">11.   workerProcess.on(&#x27;close&#x27;, function (code) &#123;</span><br><span class="line">12.    console.log(&#x27;子进程已退出，退出码 &#x27;+code);</span><br><span class="line">13.   &#125;);</span><br><span class="line">14. &#125;</span><br><span class="line">执行以上代码，输出结果为：</span><br><span class="line">1. $ node master.js stdout: 进程 0 执行。</span><br><span class="line">2. 子进程已退出，退出码 0</span><br><span class="line">3. stdout: 进程 1 执行。</span><br><span class="line">4. 子进程已退出，退出码 0</span><br><span class="line">5. stdout: 进程 2 执行。</span><br><span class="line">6. 子进程已退出，退出码 0</span><br></pre></td></tr></table></figure>
<p><strong>fork</strong> <strong>方法</strong></p>
<p>child_process.fork 是 spawn() 方法的特殊形式，用于创建进程，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. child_process.fork(modulePath[, args][, options])</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong></p>
<p>参数说明如下：</p>
<p><strong>modulePath</strong>： String，将要在子进程中运行的模块</p>
<p><strong>args</strong>： Array 字符串参数数组</p>
<p><strong>options</strong>：Object</p>
<ul>
<li>cwd String 子进程的当前工作目录</li>
<li>env Object 环境变量键值对</li>
<li>execPath String 创建子进程的可执行文件</li>
<li>execArgv Array 子进程的可执行文件的字符串参数数组（默认：     process.execArgv）</li>
<li>silent Boolean 如果为true，子进程的stdin，stdout和stderr将会被关联至父进程，否则，它们将会从父进程中继承。（默认为：false）</li>
<li>uid Number 设置用户进程的 ID</li>
<li>gid Number 设置进程组的 ID</li>
</ul>
<p>返回的对象除了拥有 ChildProcess 实例的所有方法，还有一个内建的通信信道。</p>
<p><strong>实例</strong></p>
<p>让我们创建两个 js 文件 support.js 和 master.js。</p>
<p><strong>support.js</strong> <strong>文件代码</strong>：</p>
<p>\1. console.log(“进程 “ + process.argv[2] + “ 执行。” );</p>
<p><strong>master.js</strong> <strong>文件代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. const fs = require(&#x27;fs&#x27;);</span><br><span class="line">2. const child_process = require(&#x27;child_process&#x27;);</span><br><span class="line">3. for(var i=0; i&lt;3; i++) &#123;</span><br><span class="line">4.   var worker_process = child_process.fork(&quot;support.js&quot;, [i]);</span><br><span class="line">5.   worker_process.on(&#x27;close&#x27;, function (code) &#123;</span><br><span class="line">6.    console.log(&#x27;子进程已退出，退出码 &#x27; + code);</span><br><span class="line">7.   &#125;);</span><br><span class="line">8. &#125;</span><br><span class="line">执行以上代码，输出结果为：</span><br><span class="line">1. $ node master.js</span><br><span class="line">2. 进程 0 执行。</span><br><span class="line">3. 子进程已退出，退出码 0</span><br><span class="line">4. 进程 1 执行。</span><br><span class="line">5. 子进程已退出，退出码 0</span><br><span class="line">6. 进程 2 执行。</span><br><span class="line">7. 子进程已退出，退出码 0</span><br></pre></td></tr></table></figure>
<p><strong>Node.js JXcore</strong> <strong>打包</strong></p>
<p><strong>Node.js JXcore</strong> <strong>打包</strong></p>
<p>Node.js 是一个开放源代码、跨平台的、用于服务器端和网络应用的运行环境。</p>
<p>JXcore 是一个支持多线程的 Node.js 发行版本，基本不需要对你现有的代码做任何改动就可以直接线程安全地以多线程运行。</p>
<p>介绍 JXcore 的打包功能。</p>
<p><strong>JXcore</strong> <strong>安装</strong></p>
<p>下载 JXcore 安装包，并解压，在解压的的目录下提供了 jx 二进制文件命令，接下来我们主要使用这个命令。</p>
<p><strong>步骤</strong> <strong>1**</strong>、下载**</p>
<p>下载 JXcore 安装包 <a target="_blank" rel="noopener" href="https://github.com/jxcore/jxcore-release，你需要根据你自己的系统环境来下载安装包。">https://github.com/jxcore/jxcore-release，你需要根据你自己的系统环境来下载安装包。</a></p>
<p>1、Window 平台下载：<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/jxcore/jxcore-release/master/0311/jx_win64v8.zip">Download(Windows x64 (V8))</a>。</p>
<p>2、Linux/OSX 安装命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ curl https://raw.githubusercontent.com/jxcore/jxcore/master/tools/jx_install.sh | bash</span><br></pre></td></tr></table></figure>
<p>如果权限不足，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ curl https://raw.githubusercontent.com/jxcore/jxcore/master/tools/jx_install.sh | sudo bash</span><br></pre></td></tr></table></figure>
<p>以上步骤如果操作正确，使用以下命令，会输出版本号信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ jx --versionv0.10.32</span><br></pre></td></tr></table></figure>
<p><strong>包代码</strong></p>
<p>例如，我们的 Node.js 项目包含以下几个文件，其中 index.js 是主文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. drwxr-xr-x 2 root root 4096 Nov 13 12:42 images</span><br><span class="line">2. -rwxr-xr-x 1 root root 30457 Mar 6 12:19 index.htm</span><br><span class="line">3. -rwxr-xr-x 1 root root 30452 Mar 1 12:54 index.js</span><br><span class="line">4. drwxr-xr-x 23 root root 4096 Jan 15 03:48 node_modules</span><br><span class="line">5. drwxr-xr-x 2 root root 4096 Mar 21 06:10 scripts</span><br><span class="line">6. drwxr-xr-x 2 root root 4096 Feb 15 11:56 style</span><br></pre></td></tr></table></figure>
<p>接下来我们使用 <strong>jx</strong> 命令打包以上项目，并指定 index.js 为 Node.js 项目的主文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ jx package index.js index</span><br></pre></td></tr></table></figure>
<p>以上命令执行成功，会生成以下两个文件：</p>
<ul>
<li><strong>index.jxp</strong> 这是一个中间件文件，包含了需要编译的完整项目信息。</li>
<li><strong>index.jx</strong> 这是一个完整包信息的二进制文件，可运行在客户端上。</li>
</ul>
<p><strong>载入 JX 文件</strong></p>
<p>Node.js 的项目运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ node index.js command_line_arguments</span><br></pre></td></tr></table></figure>
<p>使用 JXcore 编译后，我们可以使用以下命令来执行生成的 jx 二进制文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ jx index.jx command_line_arguments</span><br></pre></td></tr></table></figure>
<p>更多 JXcore 安装参考：<a target="_blank" rel="noopener" href="https://github.com/jxcore/jxcore/blob/master/doc/INSTALLATION.md。">https://github.com/jxcore/jxcore/blob/master/doc/INSTALLATION.md。</a></p>
<p>更多 JXcore 功能特性你可以参考官网：<a target="_blank" rel="noopener" href="https://github.com/jxcore/jxcore。">https://github.com/jxcore/jxcore。</a></p>
<p><strong>Node.js</strong> <strong>连接</strong> <strong>MySQL</strong></p>
<p><strong>Node.js</strong> <strong>连接 MySQL</strong></p>
<p>使用 Node.js 来连接 MySQL，并对数据库进行操作。</p>
<p><strong>安装驱动</strong></p>
<p>本教程使用了<a target="_blank" rel="noopener" href="https://www.axihe.com/edu/nodejs/npm.html#使用淘宝-npm-镜像">淘宝定制的 cnpm 命令</a>进行安装：</p>
<p>\1. $ cnpm install mysql</p>
<p><strong>连接数据库</strong></p>
<p>在以下实例中根据你的实际配置修改数据库用户名、及密码及数据库名：</p>
<p><strong>test.js</strong> <strong>文件代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. var mysql   = require(&#x27;mysql&#x27;);</span><br><span class="line">2. var connection = mysql.createConnection(&#123;</span><br><span class="line">3. host   : &#x27;localhost&#x27;,</span><br><span class="line">4.  user   : &#x27;root&#x27;,</span><br><span class="line">5.  password : &#x27;123456&#x27;,</span><br><span class="line">6.  database : &#x27;test&#x27;</span><br><span class="line">7. &#125;);</span><br><span class="line">8. connection.connect();</span><br><span class="line">9. connection.query(&#x27;SELECT 1 + 1 AS solution&#x27;, function (error, results, fields) &#123;</span><br><span class="line">10.  if (error) throw error;</span><br><span class="line">11.  console.log(&#x27;The solution is: &#x27;, results[0].solution);</span><br><span class="line">12. &#125;);</span><br><span class="line">执行以下命令输出结果为：</span><br><span class="line">1. $ node test.js</span><br><span class="line">2. The solution is: 2</span><br></pre></td></tr></table></figure>
<p><strong>数据库连接参数说明：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>host</td>
<td>主机地址 （默认：localhost）</td>
</tr>
<tr>
<td>user</td>
<td>用户名</td>
</tr>
<tr>
<td>password</td>
<td>密码</td>
</tr>
<tr>
<td>port</td>
<td>端口号 （默认：3306）</td>
</tr>
<tr>
<td>database</td>
<td>数据库名</td>
</tr>
<tr>
<td>charset</td>
<td>连接字符集（默认：’UTF8_GENERAL_CI’，注意字符集的字母都要大写）</td>
</tr>
<tr>
<td>localAddress</td>
<td>此 IP 用于 TCP 连接（可选）</td>
</tr>
<tr>
<td>socketPath</td>
<td>连接到 unix 域路径，当使用 host 和 port 时会被忽略</td>
</tr>
<tr>
<td>timezone</td>
<td>时区（默认：’local’）</td>
</tr>
<tr>
<td>connectTimeout</td>
<td>连接超时（默认：不限制；单位：毫秒）</td>
</tr>
<tr>
<td>stringifyObjects</td>
<td>是否序列化对象</td>
</tr>
<tr>
<td>typeCast</td>
<td>是否将列值转化为本地  JavaScript 类型值 （默认：true）</td>
</tr>
<tr>
<td>queryFormat</td>
<td>自定义 query 语句格式化方法</td>
</tr>
<tr>
<td>supportBigNumbers</td>
<td>数据库支持 bigint 或 decimal 类型列时，需要设此 option 为 true （默认：false）</td>
</tr>
<tr>
<td>bigNumberStrings</td>
<td>supportBigNumbers 和  bigNumberStrings 启用 强制 bigint 或 decimal 列以 JavaScript 字符串类型返回（默认：false）</td>
</tr>
<tr>
<td>dateStrings</td>
<td>强制 timestamp,datetime,data  类型以字符串类型返回，而不是 JavaScript Date 类型（默认：false）</td>
</tr>
<tr>
<td>debug</td>
<td>开启调试（默认：false）</td>
</tr>
<tr>
<td>multipleStatements</td>
<td>是否许一个 query 中有多个 MySQL 语句 （默认：false）</td>
</tr>
<tr>
<td>flags</td>
<td>用于修改连接标志</td>
</tr>
<tr>
<td>ssl</td>
<td>使用 ssl 参数（与 crypto.createCredenitals 参数格式一至）或一个包含 ssl  配置文件名称的字符串，目前只捆绑 Amazon RDS 的配置文件</td>
</tr>
</tbody>
</table>
</div>
<p>更多说明可参见：<a target="_blank" rel="noopener" href="https://github.com/mysqljs/mysql">https://github.com/mysqljs/mysql</a></p>
<p><strong>数据库操作 ( CURD )</strong></p>
<p>在进行数据库操作前，你需要将本站提供的 Websites 表 SQL 文件<a target="_blank" rel="noopener" href="https://static.axihe.com/download/websites.sql">websites.sql</a> 导入到你的 MySQL 数据库中。</p>
<p>测试的 MySQL 用户名为 root，密码为 123456，数据库为 test，你需要根据自己配置情况修改。</p>
<p><strong>Node.js</strong> <strong>连接</strong> <strong>MongoDB</strong></p>
<p><strong>Node.js</strong> <strong>连接 MongoDB</strong></p>
<p>MongoDB 是一种文档导向数据库管理系统，由 C++ 撰写而成。</p>
<p>如何使用 Node.js 来连接 MongoDB，并对数据库进行操作。</p>
<p><strong>安装</strong> <strong>cnpm</strong></p>
<p>本教程使用了<a target="_blank" rel="noopener" href="https://www.axihe.com/edu/nodejs/npm.html#使用淘宝-npm-镜像">淘宝定制的 cnpm 命令</a>进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. $ cnpm install mongodb</span><br></pre></td></tr></table></figure>
<p>接下来我们来实现增删改查功能。</p>
<p><strong>创建数据库</strong></p>
<p>要在 MongoDB 中创建一个数据库，首先我们需要创建一个 MongoClient 对象，然后配置好指定的 URL 和 端口号。</p>
<p>如果数据库不存在，MongoDB 将创建数据库并建立连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. var MongoClient = require(&#x27;mongodb&#x27;).MongoClient;</span><br><span class="line">2. var url = &quot;mongodb://localhost:27017/axihe&quot;;</span><br><span class="line">3. MongoClient.connect(url, &#123; useNewUrlParser: true &#125;, function(err, db) &#123;</span><br><span class="line">4.  if (err) throw err;</span><br><span class="line">5.  console.log(&quot;数据库已创建!&quot;);</span><br><span class="line">6.  db.close();</span><br><span class="line">7. &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>创建集合</strong></p>
<p>我们可以使用 createCollection() 方法来创建集合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. var MongoClient = require(&#x27;mongodb&#x27;).MongoClient;</span><br><span class="line">2. var url = &#x27;mongodb://localhost:27017/axihe&#x27;;</span><br><span class="line">3. MongoClient.connect(url, &#123; useNewUrlParser: true &#125;, function (err, db) &#123;</span><br><span class="line">4.   if (err) throw err;</span><br><span class="line">5.   console.log(&#x27;数据库已创建&#x27;);</span><br><span class="line">6.   var dbase = db.db(&quot;axihe&quot;);</span><br><span class="line">7.   dbase.createCollection(&#x27;site&#x27;, function (err, res) &#123;</span><br><span class="line">8.     if (err) throw err;</span><br><span class="line">9.     console.log(&quot;创建集合!&quot;);</span><br><span class="line">10.     db.close();</span><br><span class="line">11.   &#125;);</span><br><span class="line">12. &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>数据库操作 ( CURD )</strong></p>
<p>与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">CHEN</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/posts/20e30b1b.html">http://example.com/posts/20e30b1b.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">CHEN`Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Nodejs/">Nodejs</a></div><div class="post_share"><div class="social-share" data-image="https://sway.office.com/s/P3GYAOioiuDWbvRM/images/TUmp-j1PvPYlOe?quality=225" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://sway.office.com/s/9RTcWmiwBO2AUl3z/images/QWXHCV0DS2RHjH?quality=400" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CHEN</div><div class="author-info__description">做你说过的，说你能做的。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/czyhash"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">保持理智，期待明天<div class="twopeople"> <div class="container" style="height:200px;"> <canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas> </div> <script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js"></script> <script src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js"></script> <script id="rendered-js" src="https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js"></script> <style> .twopeople{ margin: 0; align-items: center; justify-content: center; text-align: center; } canvas { display: block; margin: 0 auto; cursor: move; } </style> </div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello-world"><span class="toc-number">1.</span> <span class="toc-text">Hello world</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8BHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">建立HTTP服务器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">Node.js</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">0.1.</span> <span class="toc-text">Hello World</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/20e30b1b.html" title="Node.js 学习笔记"><img src="https://sway.office.com/s/P3GYAOioiuDWbvRM/images/TUmp-j1PvPYlOe?quality=225" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Node.js 学习笔记"/></a><div class="content"><a class="title" href="/posts/20e30b1b.html" title="Node.js 学习笔记">Node.js 学习笔记</a><time datetime="2020-03-02T16:00:00.000Z" title="发表于 2020-03-03 00:00:00">2020-03-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By CHEN</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://mrschen.top/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论" onclick="FixedCommentBtn();"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.mrschen.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.mrschen.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="1708664797" data-server="tencent" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script data-pjax defer src="/js/custom/fixed_comment.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明" data-fontsize="15px" data-random="true" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><div class="app-refresh" id="app-refresh" style="position: fixed;top: -2.2rem;left: 0;right: 0;z-index: 99999;padding: 0 1rem;font-size: 15px;height: 2.2rem;transition: all 0.3s ease;"><div class="app-refresh-wrap" style=" display: flex;color: #fff;height: 100%;align-items: center;justify-content: center;"><label>✨ 有新文章啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color: #fff;text-decoration: underline;cursor: pointer;">🍗点击食用🍔</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '✨ 有新文章啦！ 👉',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '🍗点击食用🍔',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#49b1f5' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = '39966137b6d8b89282ff82c25a08af2b';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '116.404,39.915';
  var clock_default_rectangle_enable = 'true';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><div id="ghbdages" style="overflow:hidden;max-height:90px;height:auto;text-align:center;margin-top:10px"><div class="swiper-wrapper"><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v5.4.0"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v3.8.2"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel"><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用双线部署，联通线路托管于Coding"><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&amp;logo=Codio" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本站项目由Github托管"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></div></div></div><style>a.github-badge:hover:before {display:none}</style>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/rutime.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="/js/ali_font.js"></script><script data-pjax src="https://cdn.cbd.int/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://github.anzhiy.cn/api?czyhash",['#e4dfd7', '#f9f4dc', '#f7e8aa', '#f7e8aa', '#f8df72', '#fcd217', '#fcc515', '#f28e16', '#fb8b05', '#d85916', '#f43e06'],'czyhash')
    }
  </script><!-- hexo injector body_end end --></body></html>